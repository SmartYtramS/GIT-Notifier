1c1
< #! /usr/bin/env python
---
> #!/usr/bin/env python
2a3,9
> '''
> This is a fork of ICIR.org git-notifier that implements colorized diff support
> plus some other nice things.
> Please refer to https://github.com/tb0hdan/GIT-Notifier for more detail.
> '''
> 
> # pylint: disable=C0103,C0302
10,18c17,53
< import time
< 
< VERSION   = "0.3-16"  # Filled in automatically.
< 
< Name      = "git-notifier"
< CacheFile = ".%s.dat" % Name
< Separator = "\n>---------------------------------------------------------------\n"
< NoDiff    = "[nodiff]"
< NoMail    = "[nomail]"
---
> import logging
> import smtplib
> from time import asctime as time_asctime
> from re import sub as re_sub, search as re_search, split as re_split
> from email.mime.multipart import MIMEMultipart
> from email.mime.text import MIMEText
> 
> try:
>     eval("1 if True else 2")
> except SyntaxError:
>     raise ImportError("This software requires ternary support.")
> 
> try:
>     import pygments
>     from pygments import highlight
>     from pygments.lexers import DiffLexer # pylint: disable=E0611
>     from pygments.formatters import HtmlFormatter # pylint: disable=E0611
>     # pylint: disable=E0611
>     from pygments.styles import get_style_by_name, STYLE_MAP
>     pygments_available = True
> except ImportError:
>     pygments_available = False
> 
> if pygments_available:
>     if float(pygments.__version__) < 0.7:
>         logging.warning('You have an outdated Pygments version installed.')
>         logging.warning('Disabling Pygments support.')
>         pygments_available = False
> 
> VERSION       = "0.4"
> ProjectURL    = "https://github.com/tb0hdan/GIT-Notifier"
> Name          = "git-notifier"
> CacheFile     = ".%s.dat" % Name
> Separator     = "\n>%s\n" % ('-' * 62)
> Separhtml     = "<hr>"
> NoDiff        = "[nodiff]"
> NoMail        = "[nomail]"
21c56,61
< whoami = os.environ["LOGNAME"]
---
> # Git via Apache/DAV fix
> try:
>     whoami = os.environ["LOGNAME"]
> except KeyError:
>     import getpass
>     whoami =  getpass.getuser()
26c66,69
<     ("allchanges", True, set(), "branches for which *all* changes are to be reported"),
---
>     ("allchanges", True, set(),
>      "branches for which *all* changes are to be reported"),
>     ("altsubject", False, False,
>      "enables alternative subject with repository name"),
30c73,78
<     ("hostname", True, socket.gethostname(), "host where the repository is hosted"),
---
>     ("disablefooter", False, False, 
>     "enables page footer for all commit messages"),
>     ("digest", False, False,
>     "Send multiple commit notification as single message"),
>     ("hostname", True, socket.gethostname(),
>      "host where the repository is hosted"),
33c81,86
<     ("manual", True, None, "notifiy for a manually given set of revisions"),
---
>     ("smtpserver", True, 'localhost', "tells SMTP server to use, host only"),
>     ("smtpport", True, 25, "sets SMTP port for SMTP server"),
>     ("smtplogin", True, None, "sets login for SMTP AUTH"),
>     ("smtppassword", True, None, "sets password for SMTP AUTH"),
>     ("smtpssl", False, False, "enables SSL for SMTP"),
>     ("manual", True, None, "notify for a manually given set of revisions"),
34a88,90
>     ("colordiff", False, False, "colorize diffs using pygments library"),
>     ("colorstyle", True, "tango",
>     "defines style for colordiff option"),
38c94,95
<     ("link", True, None, "Link to insert into mail, %s will be replaced with revision"),
---
>     ("link", True, None,
>      "Link to insert into mail, %s will be replaced with revision"),
42c99,100
<     ("mergediffs", True, set(), "branches for which complete merge diffs are to be included"),
---
>     ("mergediffs", True, set(),
>      "branches for which complete merge diffs are to be included"),
45c103,107
< class State:
---
> 
> class State(object):
>     '''
>     State class
>     '''
49a112,114
>         '''
>         Clear data structures
>         '''
57a123,125
>         '''
>         Write to cache file
>         '''
67c135
<             print >>out, "head", head, ref
---
>             print >> out, "head", head, ref
70c138
<             print >>out, "tag", tag, ref
---
>             print >> out, "tag", tag, ref
73c141
<             print >>out, "rev", rev
---
>             print >> out, "rev", rev
75,78d142
<         # No longer used.
<         #
<         # for rev in self.diffs:
<         #     print >>out, "diff", rev
80a145,147
>         '''
>         Read from cache file
>         '''
112c179,182
< class GitConfig:
---
> class GitConfig(object):
>     '''
>     GitConfig class
>     '''
115c185,187
<         self.maxdiffsize *= 1024 # KBytes to bytes.
---
>         # KBytes to bytes.
>         self.maxdiffsize *= 1024 # pylint: disable=E1101
> 
118c190,191
<             self.allchanges = set([head.strip() for head in self.allchanges.split(",")])
---
>             self.allchanges = \
>                 set([head.strip() for head in self.allchanges.split(",")])
121c194,196
<             self.mergediffs = set([head.strip() for head in self.mergediffs.split(",")])
---
>             # pylint: disable=E1101
>             self.mergediffs = \
>                 set([head.strip() for head in self.mergediffs.split(",")])
123c198
<         if not self.debug:
---
>         if not self.debug: # pylint: disable=E1101
136c211,213
< 
---
>         '''
>         Parse command line arguments
>         '''
150c227,228
<                 parser.add_option("--%s" % name, action=action, dest=name, default=defval, help=help)
---
>                 parser.add_option("--%s" % name, action=action, dest=name,
>                     default=defval, help=help)
154c232,233
<                 parser.add_option("--%s" % name, action="store", type=type, default=defval, dest=name, help=help)
---
>                 parser.add_option("--%s" % name, action="store", type=type,
>                     default=defval, dest=name, help=help)
164a244,246
>         '''
>         Read users from configuration file
>         '''
177a260,262
>         '''
>         Return git configuration
>         '''
180a266,655
> class Colorer(object):
>     '''
>     Simple class that uses Pygments library to provide colorized
>     output (full HTML) for diffs.
>     '''
>     def __init__(self):
>         self.result = ''
>         if pygments_available:
>             if not Config.colorstyle in STYLE_MAP:
>                 logging.warning('Specified color style not available.')
>                 logging.warning('Using default instead.')
>                 self.style = 'default'
>             else:
>                 self.style = Config.colorstyle
>             self.formatter = HtmlFormatter(linenos=True, full=True,
>                 encoding="utf-8", style=get_style_by_name(self.style))
>             self.lexerobj  = DiffLexer()
> 
>     def formatDiff(self, data=None):
>         '''
>         Format diff
>         '''
>         self.data = data
>         if self.data:
>             try:
>                 self.result = highlight(self.data, self.lexerobj,
>                     self.formatter)
>             except:
>                 self.result = self.data
>         return self.result
> 
>     def colorizeFile(self, fname=None, key_start=None, key_end=None):
>         '''
>         Colorizes input file. Result is HTML.
>         '''
>         if fname and os.path.exists(fname):
>             __data = readfile(fname)
>             # We have data, good.
>             if (key_start == None) and (key_end == None):
>                 return self.formatDiff(__data)
>             else:
>                 # Since we have text file here such split works just fine.
>                 __trigger = False
>                 __result_data = __noformat_data = ''
>                 for line in __data.split('\n'):
>                     if key_start and (re_search(key_start, line) != None):
>                         __trigger = True
>                     if key_end   and (re_search(key_end,   line) != None):
>                         __trigger = False
>                     if  __trigger:
>                         __result_data += line + '\n'
>                     else:
>                         __noformat_data += line + '\n'
>                 __noformat_data ='<pre>%s</pre>' % __noformat_data
>                 __result_data = '%s\n%s' % (__noformat_data,
>                         self.formatDiff(__result_data))
>                 return __result_data
>         else:
>             return None
> 
> class PrettyHTML(object):
>     '''
>     Simple class to make 'git show' message look prettier
>     '''
>     def __init__(self, subject=None):
>         self.keywords = ['commit', 'Author:', 'Date:']
>         # If True all next messages are not checked against keywords
>         self.keywords_trigger = False
>         # Contains additional tags before the commit message
>         self.extra_tags = ''
>         # Mailto subject part
>         self.subject = subject
>         if not self.subject:
>             self.subject = 'Git commit'
> 
>     def transcode(self, line):
>         '''
>         Encodes characters to HTML
>         '''
>         self.line = line
>         self.line = self.line.replace('<', '&lt;').replace('>', '&gt;')
>         # Required for mailto subject encoding
>         self.line = self.line.replace(' ', '%20')
>         return self.line
> 
>     def make_bold(self, keyword, line):
>         '''
>         Makes text bold
>         '''
>         part1 = ''
>         part2 = ''
>         if (re_search(keyword, line) != None) and \
>             (self.keywords_trigger == False):
>             if re_search(':', keyword) == None:
>                 replacement = '%s:' % keyword
>             else:
>                 replacement = keyword
>             # commit replacement
>             if (keyword in self.keywords) and (not replacement[:1].isupper()):
>                 replacement = replacement[0].upper() + replacement[1:]
>             # git commit email
>             if re_search('[A|a]uthor', keyword) != None:
>                 try:
>                     part1 = re_split('<(.*)>', line)[0].strip()
>                     part2 = re_split('<(.*)>', line)[1].strip()
>                 except:
>                     log("Broken email?")
>                 if (part1 != '') and (part2 != ''):
>                     email = part2
>                     uri = '<a href="mailto:%s?subject=%s">&lt;%s&gt;</a>' % \
>                      (email, self.transcode(self.subject), email)
>                     line = part1 + ' ' + uri
>             line = line.replace(keyword, '<b>%s</b>' % replacement)
>             line = "<br>%s" % line
>         return line
> 
>     def convert(self, line):
>         '''
>         Convert 'git show' keywords
>         '''
>         replacements = 0
>         for keyword in self.keywords:
>             line_orig = line
>             line = self.make_bold(keyword, line)
>             if line != line_orig:
>                 replacements += 1
>         # No replacements were made, assume we have commit message
>         if replacements == 0:
>             if self.keywords_trigger == False:
>                 self.keywords_trigger = True
>                 self.extra_tags = '<br>'
>             else:
>                 # Only on-change lines should have extra tags
>                 self.extra_tags = ''
>             line = '%s<br><b>%s</b>' % (self.extra_tags, line)
>         return line
> 
> class Mail(object):
>     '''
>     Simple class for notifications via SMTP
>     '''
>     def __init__(self, smtp_host, smtp_port, smtp_login,
>         smtp_password, smtp_usessl):
> 
>         self.smtp_host = smtp_host
>         self.smtp_port = smtp_port
>         self.smtp_login = smtp_login
>         self.smtp_password = smtp_password
>         self.smtp_usessl = smtp_usessl
>         # Create message container
>         # The correct MIME type is multipart/alternative.
>         self.msg = MIMEMultipart('alternative')
> 
> 
>     def addHeader(self, header, value, header_append=False):
>         '''
>         Adds message header
>         '''
>         # Verify presence of header
>         if self.msg[header]:
>             # Header already set, look out for recepient duplicates!
>             if not header_append:
>                 return False
>             del self.msg[header]
>         # Set message header
>         self.msg[header] = value
>         return True
> 
>     def addPart(self, content_type, content, encoding=None):
>         '''
>         Adds message part
>         '''
>         if encoding:
>             # Use specified encoding
>             part = MIMEText(content, content_type, encoding)
>         else:
>             # Fallback to us-ascii
>             part = MIMEText(content, content_type)
>         return part
> 
>     def attach(self, part):
>         '''
>         Attach message part
>         '''
>         self.msg.attach(part)
> 
>     def attachHtml(self, content):
>         '''
>         Attach HTML message
>         '''
>         part = self.addPart('html', content, 'utf8')
>         self.attach(part)
> 
>     def attachText(self, content):
>         '''
>         Attach text message
>         '''
>         part = self.addPart('plain', content)
>         self.attach(part)
> 
>     def getMessage(self):
>         '''
>         Return whole message (so far)
>         '''
>         return self.msg
> 
>     def send(self, smtp_sender, smtp_mailinglist, smtp_data):
>         '''
>         Send email via SMTP
>         '''
>         log("Sending email to %s" % smtp_mailinglist)
>         self.connection = smtplib.SMTP(self.smtp_host)
>         try:
>             # identify ourselves, prompting server for supported features
>             self.connection.ehlo()
> 
>             # Encrypt connection if both server supports it
>             # and self.smtp_usessl is True
>             if self.connection.has_extn('STARTTLS') and self.smtp_usessl:
>                 self.connection.starttls()
>                 # re-identify ourselves over TLS connection
>                 self.connection.ehlo()
> 
>             # Enable SMTP AUTH if both self.smtp_login and
>             # self.smtp_password are not empty.
>             if self.smtp_login and self.smtp_password:
>                 self.connection.login(self.smtp_login, self.smtp_password)
> 
>             # Send message
>             self.connection.sendmail(smtp_sender, smtp_mailinglist, smtp_data)
>         except:
>             # Status of message: delivery failed
>             return False
>         finally:
>             self.connection.quit()
>         # Status of message: delivery successful
>         return True
>         
> class MailWrapper(object):
>     '''
>     MailWrapper class provides high level interface to Mail class
>     '''
>     def __init__(self, mail_object):
>         self.mail = mail_object
>         self.isLastCommit = True
>         self.text_message_defaults = ''
>         self.text_message = self.text_message_defaults
>         self.html_message_defaults = '<html>\n'
>         self.html_message = self.html_message_defaults
> 
>     def init(self, text=None, html=None):
>         '''
>         Start with reasonable defaults.
>         '''
>         if text:
>             self.text_message = text
>         elif not Config.digest:
>             self.text_message = self.text_message_defaults
>         if html:
>             self.html_message = html
>         elif not Config.digest:
>             self.html_message = self.html_message_defaults
> 
>     def sendFile(self, out, fname):
>         '''
>         Send file contents via SMTP
>         '''
>         out.close()
>         if Config.debug: # pylint: disable=E1101
>             for line in open(fname):
>                 print "    |", line,
>             print ""
>         elif self.isLastCommit:
>             _data = readfile(fname)
>             # pylint: disable=E1101
>             self.mail.send(Config.sender, Config.mailinglist, _data)
> 
>     def generateMailHeader(self, subject):
>         '''
>         Generates mail header
>         '''
>         # Reply-To equals to sender, if not set.
>         # pylint: disable=E1101
>         replyto = 'Reply-To: %s\n' % \
>             Config.replyto if Config.replyto else Config.sender
>         if Config.altsubject:
>             subject = ('Repository: %s Branch: %s ' % \
>                 (re_sub('ssh://(.+)/', '',repo), subject))
> 
>         # Set message headers
>         self.mail.addHeader('From', Config.sender)
>         self.mail.addHeader('To', Config.mailinglist)
>         # Allow only 'Subject' header replacement.
>         self.mail.addHeader('Subject',
>             Config.emailprefix + subject, header_append=True)
>         self.mail.addHeader('Reply-To', replyto)
>         self.mail.addHeader('X-Git-Repository', repo)
>         self.mail.addHeader('X-Mailer', Name + ' ' + VERSION)
> 
>     def addTag(self, key, value):
>         '''
>         Adds message tag
>         '''
>         if Config.colordiff: # pylint: disable=E1101
>             formatted = '<br><b>%-11s:</b> %s\n' % (key, value)
>             self.addLine(formatted, html_only=True, start_br=False)
>         else:
>             formatted = '%-11s: %s' % (key, value)
>             self.addLine(formatted, text_only=True)
> 
>     def __br_process(self, start_br, message, line):
>         '''
>         Internal method to stay DRY
>         '''
>         if start_br:
>             message += '<br>%s' % line
>         else:
>             message += line
>         return message
> 
>     def addLine(self, line, text_only=False, html_only=False, start_br=True):
>         '''
>         Adds message line
>         '''
>         if text_only:
>             self.text_message += line
>             return True
>         if html_only:
>             if Config.colordiff: # pylint: disable=E1101
>                 self.html_message = self.__br_process(start_br, 
>                     self.html_message,line)
>             return True
>         self.text_message += line
>         if Config.colordiff: # pylint: disable=E1101
>             self.html_message = self.__br_process(start_br, 
>                 self.html_message, line)
>         return True
> 
>     def setMultiCommit(self, isMultiCommit=False):
>         '''
>         Tells other methods in class that we have multiple commits.
>         '''
>         self.isMultiCommit = isMultiCommit
>         if self.isMultiCommit and Config.digest:
>             self.isLastCommit = False
>         return True
> 
>     def setLastCommit(self, isLastCommit=False):
>         '''
>         Tells other methods in class that we have last commit of mutliple.
>         '''
>         if Config.digest:
>             self.isLastCommit = isLastCommit
>         return True
> 
>     def getMessage(self):
>         '''
>         Returns whole message
>         '''
>         # Add footer to our message (in digest mode do this only once)
>         if Config.disablefooter == False and self.isLastCommit == True:
>             self.footerTextMessage = 'Generated by %s/%s: %s' % (Name,
>                 VERSION, ProjectURL)
>             self.footerHtmlMessage = '<br><hr>\nGenerated by %s<br>\n' % \
>                 ('<a href="%s">%s/%s</a>' % (ProjectURL, Name, VERSION))
>             self.text_message = '%s\n%s\n' % (self.text_message, 
>                 self.footerTextMessage)
>             self.html_message = '%s\n%s\n' % (self.html_message,
>                 self.footerHtmlMessage)
>         # Message parts should be always attached before returning the message.
>         self.mail.attachText(self.text_message)
>         if Config.colordiff: # pylint: disable=E1101
>             self.mail.attachHtml(self.html_message)
>         return self.mail.getMessage()
> 
> def readfile(filename=None, mode='r+b'):
>     '''
>     Returns data read from file
>     '''
>     file_data = ''
>     if filename and os.path.exists(filename):
>         f = open(filename, mode)
>         try:
>             file_data = f.read()
>         except:
>             error("Reading file %s failed" % filename)
>         finally:
>             f.close()
>     return file_data
> 
182c657,660
<     print >>Config.log, "%s - %s" % (time.asctime(), msg)
---
>     '''
>     Shows message to remote party
>     '''
>     print >> Config.log, "%s - %s" % (time_asctime(), msg)
184a663,665
>     '''
>     Uses log() function to notify remote party of errors
>     '''
188a670,672
>     '''
>     Provides pythonic interface to git executable
>     '''
193,194c677,678
<         if Config.debug:
<             print >>sys.stderr, "> git " + args
---
>         if Config.debug: # pylint: disable=E1101
>             print >> sys.stderr, "> git " + args
200c684,685
<         child = subprocess.Popen("git " + args, shell=True, stdin=None, stdout=stdout_to, stderr=subprocess.PIPE)
---
>         child = subprocess.Popen("git " + args, shell=True, stdin=None,
>             stdout=stdout_to, stderr=subprocess.PIPE)
217a703,705
>     '''
>     Retrieves information about repository heads
>     '''
224a713,715
>     '''
>     Retrieves information about repository tags
>     '''
227c718
<         type = git("cat-file -t %s" % rev)[0]
---
>         tag_type = git("cat-file -t %s" % rev)[0]
229c720
<         if type == "tag":
---
>         if tag_type == "tag":
231c722
<                 tag= tag[10:]
---
>                 tag = tag[10:]
235a727,730
>     '''
>     Retrieves information about reachable repository revisions.
>     Result is an array.
>     '''
239a735,737
>     '''
>     Read current state from file.
>     '''
247,248d744
< Tmps = []
< 
249a746,748
>     '''
>     Create temporary files
>     '''
257a757,759
>     '''
>     Delete temporary files
>     '''
261,267c763,767
< def mailTag(key, value):
<     return "%-11s: %s" % (key, value)
< 
< def generateMailHeader(subject):
< 
<     repo = Config.repouri
< 
---
> def getRepo():
>     '''
>     Retrieve repository path
>     '''
>     repo = Config.repouri # pylint: disable=E1101
269d768
< 
272c771,773
<             repo = "ssh://%s@%s/%s" % (whoami, Config.hostname, os.path.basename(os.getcwd()))
---
>             # pylint: disable=E1101
>             repo = "ssh://%s@%s/%s" % (whoami, Config.hostname,
>                 os.path.basename(os.getcwd()))
275,276c776,778
<             repo = "ssh://%s/%s" % (Config.hostname, os.path.basename(os.getcwd()))
< 
---
>             # pylint: disable=E1101
>             repo = "ssh://%s/%s" % (Config.hostname,
>                 os.path.basename(os.getcwd()))
279,314c781
< 
<     (out, fname) = makeTmp()
< 
<     replyto = "Reply-To: %s\n" % Config.replyto if Config.replyto else ""
< 
<     print >>out, """From: %s
< To: %s
< Subject: %s %s
< %sX-Git-Repository: %s
< X-Mailer: %s %s
< 
< %s
< 
< """ % (Config.sender, Config.mailinglist, Config.emailprefix, subject, replyto, repo,
<        Name, VERSION, mailTag("Repository", repo)),
< 
<     return (out, fname)
< 
< def sendMail(out, fname):
<     out.close()
< 
<     if Config.debug:
<         for line in open(fname):
<             print "    |", line,
<         print ""
<     else:
<         stdin = subprocess.Popen("/usr/sbin/sendmail -t", shell=True, stdin=subprocess.PIPE).stdin
<         for line in open(fname):
<             print >>stdin, line,
<         stdin.close()
< 
<     # Wait a bit in case we're going to send more mails. Otherwise, the mails
<     # get sent back-to-back and are likely to end up with identical timestamps,
<     # which may then make them appear to have arrived in the wrong order.
<     if not Config.debug:
<         time.sleep(2)
---
>     return repo
316a784,786
>     '''
>     Hook for adding an entry
>     '''
317a788
>     (out, fname) = makeTmp()
319,324c790,799
<     (out, fname) = generateMailHeader("%s '%s' created" % (key, value))
< 
<     print >>out, mailTag("New %s" % key, value)
<     print >>out, mailTag("Referencing", rev)
< 
<     sendMail(out, fname)
---
>     # Initialize message
>     message.init()
>     message.generateMailHeader("%s '%s' created" % (key, value))
> 
>     message.addTag("New %s" % key, value)
>     message.addTag("Referencing", rev)
> 
>     # print whole message to file
>     print >> out, message.getMessage()
>     message.sendFile(out, fname)
326a802,804
>     '''
>     Hook for deleting an entry
>     '''
327a806
>     (out, fname) = makeTmp()
329,333c808,816
<     (out, fname) = generateMailHeader("%s '%s' deleted" % (key, value))
< 
<     print >>out, mailTag("Deleted %s" % key, value)
< 
<     sendMail(out, fname)
---
>     # Initialize message
>     message.init()
>     message.generateMailHeader("%s '%s' deleted" % (key, value))
> 
>     message.addTag("Deleted %s" % key, value)
> 
>     # print whole message to file
>     print >> out, message.getMessage()
>     message.sendFile(out, fname)
335,336d817
< # Sends a mail for a notification consistent of two parts: (1) the output of a
< # show command, and (2) the output of a diff command.
338,339c819,830
< 
<     (out, fname) = generateMailHeader(subject)
---
>     '''
>     Sends a mail for a notification consistent of two parts: (1) the output of
>     a show command, and (2) the output of a diff command.
>     '''
>     # The 'git show' prettifier
>     prettyhtml = PrettyHTML(subject='Git commit %s' % subject[-9:])
>     # Initialize message
>     message.init()
>     message.generateMailHeader(subject)
>     (out, fname) = makeTmp()
>     #
>     message.addTag("Repository", repo)
344c835
<     print >>out, mailTag("On branch%s" % multi, heads)
---
>     message.addTag("On branch%s" % multi, heads)
346,348c837,839
<     if Config.link:
<         url = Config.link.replace("%s", rev)
<         print >>out, mailTag("Link", url)
---
>     if Config.link: # pylint: disable=E1101
>         url = Config.link.replace("%s", rev) # pylint: disable=E1101
>         message.addTag("Link", url)
361a853
>         # TODO: Find better place for this
366,368c858,860
< 
<         if size > Config.maxdiffsize:
<             footer = "\nDiff suppressed because of size. To see it, use:\n\n    git %s" % diff_cmd
---
>         if size > Config.maxdiffsize: # pylint: disable=E1101
>             footer = "\nDiff suppressed because of size.\n \
>                 To see it, use:\n\n    git %s" % diff_cmd
371c863,865
<     print >>out, Separator
---
>     message.addLine(Separator, text_only=True)
>     # Use nice <hr> in html mode
>     message.addLine(Separhtml, html_only=True)
375c869,870
<             print >>out, Separator
---
>             message.addLine(Separator, text_only=True)
>             message.addLine(Separhtml, html_only=True)
377c872,874
<             print >>out, line
---
>             message.addLine(line + "\n", text_only=True)
>             message.addLine(prettyhtml.convert(line) + "\n",
>                 html_only=True, start_br=False)
379c876,877
<     print >>out, Separator
---
>     message.addLine(Separator, text_only=True)
>     message.addLine(Separhtml, html_only=True)
380a879
>     # Text only, read diff from file
383c882
<             print >>out, line,
---
>             message.addLine(line, text_only=True)
385c884,904
<     print >>out, footer
---
>     # HTML only, read and parse diff
>     if Config.colordiff and tname: # pylint: disable=E1101
>         colorer = Colorer()
>         message.addLine('\n', html_only=True, start_br=False)
>         message.addLine(colorer.colorizeFile(tname, key_start='diff\ --git'),
>             html_only=True, start_br=False)
> 
>     message.addLine(footer, text_only=True)
>     message.addLine(footer.replace("\n", "<br>\n"), html_only=True)
> 
>     if Config.debug: # pylint: disable=E1101
>         message.addLine("-- ", text_only=True)
>         # Use nice <hr> in html mode
>         message.addLine(Separhtml, html_only=True)
>         # Both text and html
>         message.addLine("debug: show_cmd = git %s" % show_cmd)
>         message.addLine("debug: diff_cmd = git %s" % diff_cmd)
> 
>     # print whole message to file
>     print >> out, message.getMessage()
>     message.sendFile(out, fname)
387,394d905
<     if Config.debug:
<         print >>out, "-- "
<         print >>out, "debug: show_cmd = git %s" % show_cmd
<         print >>out, "debug: diff_cmd = git %s" % diff_cmd
< 
<     sendMail(out, fname)
< 
< # Sends notification for a specific revision.
395a907,909
>     '''
>     Sends notification for a specific revision.
>     '''
398c912,913
<         log("Flagged revision %s for notification, but already reported this time" % rev)
---
>         log("Flagged revision %s for notification, \
>             but already reported this time" % rev)
417,418c932,935
<     show_cmd = "show -s --no-color --find-copies-harder --pretty=medium %s" % rev
<     diff_cmd = "diff-tree --patch-with-stat --no-color --find-copies-harder --ignore-space-at-eol %s %s" % (merge_diff, rev)
---
>     show_cmd = "show -s --no-color --find-copies-harder \
>         --pretty=medium %s" % rev
>     diff_cmd = "diff-tree --patch-with-stat --no-color --find-copies-harder \
>         --ignore-space-at-eol %s %s" % (merge_diff, rev)
422,424d938
< # Sends a diff between two revisions.
< #
< # Only used in manual mode now.
425a940,943
>     '''
>     Sends a diff between two revisions.
>     Only used in manual mode now.
>     '''
439,440c957,960
<     show_cmd = "show -s --no-color --find-copies-harder --pretty=medium %s" % last
<     diff_cmd = "diff --patch-with-stat -m --no-color --find-copies-harder --ignore-space-at-eol %s %s" % (first, last)
---
>     show_cmd = "show -s --no-color --find-copies-harder \
>         --pretty=medium %s" % last
>     diff_cmd = "diff --patch-with-stat -m --no-color --find-copies-harder \
>         --ignore-space-at-eol %s %s" % (first, last)
444,447d963
< # Sends pair-wise diffs for a path of revisions. Also records all revision on
< # the path as seen.
< #
< # Only used in manual mode now.
448a965,969
>     '''
>     Sends pair-wise diffs for a path of revisions. Also records all revision on
>     the path as seen.
>     Only used in manual mode now.
>     '''
456d976
< # Sends a commit notifications for a set of revisions.
457a978,980
>     '''
>     Sends a commit notifications for a set of revisions.
>     '''
463a987,989
>     if len(revs) > 1:
>         message.setMultiCommit(True)
> 
464a991,993
>         # Get last revision
>         if rev == revs[len(revs)-1]:
>             message.setLastCommit(True)
467c996
< # Sends a summary mail for a set of revisions.
---
> 
468a998,1000
>     '''
>     Sends a summary mail for a set of revisions.
>     '''
469a1002
>     (out, fname) = makeTmp()
473c1006,1008
<     (out, fname) = generateMailHeader("%s's head updated: %s" % (head, subject[0]))
---
>     # Initialize message
>     message.init()
>     message.generateMailHeader("%s's head updated: %s" % (head, subject[0]))
475,476c1010,1011
<     print >>out, "Branch '%s' now includes:" % head
<     print >>out, ""
---
>     message.addLine("Branch '%s' now includes:" % head)
>     message.addLine("")
479c1014,1019
<         print >>out, "    ", git("show -s --pretty=oneline --abbrev-commit %s" % rev)[0]
---
>         message.addLine("    " +
>             str(git("show -s --pretty=oneline --abbrev-commit %s" % rev)[0]))
> 
>     # print whole message to file
>     print >> out, message.getMessage()
>     message.sendFile(out, fname)
481c1021,1022
<     sendMail(out, fname)
---
> # Main run
> Tmps = []
483a1025,1031
> # pylint: disable=E1101
> mail = Mail(Config.smtpserver, Config.smtpport,
>             Config.smtplogin, Config.smtppassword, Config.smtpssl)
> 
> message = MailWrapper(mail)
> 
> repo = getRepo()
489c1037
<         print >>sys.stderr, "[Option %s: %s]" % (name, Config.__dict__[name])
---
>         print >> sys.stderr, "[Option %s: %s]" % (name, Config.__dict__[name])
561c1109,1110
<         path = git(["rev-list", "--reverse --date-order", new_rev, "^%s" % old_rev])
---
>         path = git(["rev-list",
>             "--reverse --date-order", new_rev, "^%s" % old_rev])
