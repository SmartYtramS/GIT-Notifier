#!/usr/bin/env python

import optparse
import os
import shutil
import socket
import sys
import subprocess
import tempfile
import time

import smtplib
from re import sub as re_sub, search as re_search
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

try:
    from pygments import highlight
    from pygments.lexers import DiffLexer
    from pygments.formatters import HtmlFormatter
    pygments_available = True
except ImportError:
    pygments_available = False

VERSION   = "0.3-16"  # Filled in automatically.

Name      = "git-notifier"
CacheFile = ".%s.dat" % Name
Separator = "\n>%s\n" % ('-' * 62)
Separhtml = "<hr>"
NoDiff    = "[nodiff]"
NoMail    = "[nomail]"


gitolite = "GL_USER" in os.environ
whoami = os.environ["LOGNAME"]
sender = os.environ["GL_USER"] if gitolite else whoami

Options = [
    # Name, argument, default, help,
    ("allchanges", True, set(),
     "branches for which *all* changes are to be reported"),
    ("altsubject", False, False,
     "enables alternative subject with repository name"),
    ("debug", False, False, "enable debug output"),
    ("diff", True, None, "mail out diffs between two revisions"),
    ("emailprefix", True, "[git]", "Subject prefix for mails"),
    ("hostname", True, socket.gethostname(),
     "host where the repository is hosted"),
    ("log", True, "%s.log" % Name, "set log output"),
    ("mailinglist", True, whoami, "destination address for mails"),
    ("smtpserver", True, 'localhost', "tells SMTP server to use, host only"),
    ("smtpport", True, 25, "sets SMTP port for SMTP server"),
    ("smtplogin", True, None, "sets login for SMTP AUTH"),
    ("smtppassword", True, None, "sets password for SMTP AUTH"),
    ("smtpssl", False, False, "enables SSL for SMTP"),
    ("manual", True, None, "notify for a manually given set of revisions"),
    ("maxdiffsize", True, 50, "limit the size of diffs in mails (KB)"),
    ("colordiff", False, False, "colorize diffs using pygments library"),
    ("noupdate", False, False, "do not update the state file"),
    ("repouri", True, None, "full URI for the repository"),
    ("sender", True, sender, "sender address for mails"),
    ("link", True, None,
     "Link to insert into mail, %s will be replaced with revision"),
    ("updateonly", False, False, "update state file only, no mails"),
    ("users", True, None, "location of a user-to-email mapping file"),
    ("replyto", True, None, "email address for reply-to header"),
    ("mergediffs", True, set(),
     "branches for which complete merge diffs are to be included"),
    ]


class State(object):
    '''
    State class
    '''
    def __init__(self):
        self.clear()

    def clear(self):
        '''
        Clear data structures
        '''
        self.heads = {}
        self.tags = {}
        self.revs = set()
        self.diffs = set()

        self.reported = set() # Revs reported this run so far.

    def writeTo(self, file):
        '''
        Write to cache file
        '''
        if os.path.exists(CacheFile):
            try:
                shutil.move(CacheFile, CacheFile + ".bak")
            except IOError:
                pass

        out = open(file, "w")

        for (head, ref) in self.heads.items():
            print >>out, "head", head, ref

        for (tag, ref) in self.tags.items():
            print >>out, "tag", tag, ref

        for rev in self.revs:
            print >>out, "rev", rev

        # No longer used.
        #
        # for rev in self.diffs:
        #     print >>out, "diff", rev

    def readFrom(self, file):
        '''
        Read from cache file
        '''
        self.clear()

        for line in open(file):

            line = line.strip()
            if not line or line.startswith("#"):
                continue

            m = line.split()

            if len(m) == 3:
                (type, key, val) = (m[0], m[1], m[2])
            else:
                # No heads.
                (type, key, val) = (m[0], m[1], "")

            if type == "head":
                self.heads[key] = val

            elif type == "tag":
                self.tags[key] = val

            elif type == "rev":
                self.revs.add(key)

            elif type == "diff":
                self.diffs.add(key)

            else:
                error("unknown type %s in cache file" % type)

class GitConfig(object):
    '''
    GitConfig class
    '''
    def __init__(self, args):
        self.parseArgs(args)
        self.maxdiffsize *= 1024 # KBytes to bytes.

        if self.allchanges and not isinstance(self.allchanges, set):
            self.allchanges = \
                set([head.strip() for head in self.allchanges.split(",")])

        if self.mergediffs and not isinstance(self.mergediffs, set):
            self.mergediffs = \
                set([head.strip() for head in self.mergediffs.split(",")])

        if not self.debug:
            self.log = open(self.log, "a")
        else:
            self.log = sys.stderr

        if not self.users and "GL_ADMINDIR" in os.environ:
            users = os.path.join(os.environ["GL_ADMINDIR"], "conf/sender.cfg")
            if os.path.exists(users):
                self.users = users

        self.readUsers()

    def parseArgs(self, args):
        '''
        Parse command line arguments
        '''
        parser = optparse.OptionParser(version=VERSION)

        for (name, arg, default, help) in Options:
            defval = self._git_config(name, default)

            if isinstance(default, int):
                defval = int(defval)

            if not arg:
                defval = bool(defval)

            if not arg:
                action = "store_true" if not default else "store_false"
                parser.add_option("--%s" % name, action=action, dest=name,
                    default=defval, help=help)

            else:
                type = "string" if not isinstance(default, int) else "int"
                parser.add_option("--%s" % name, action="store", type=type,
                    default=defval, dest=name, help=help)

        (options, args) = parser.parse_args(args)

        if len(args) != 0:
            parser.error("incorrect number of arguments")

        for (name, arg, default, help) in Options:
            self.__dict__[name] = options.__dict__[name]

    def readUsers(self):
        '''
        Read users from configuration file
        '''
        if self.users and os.path.exists(self.users):
            for line in open(self.users):
                line = line.strip()
                if not line or line.startswith("#"):
                    continue

                m = line.split()

                if self.sender == m[0]:
                    self.sender = " ".join(m[1:])
                    break

    def _git_config(self, key, default):
        '''
        Return git configuration
        '''
        cfg = git(["config hooks.%s" % key])
        return cfg[0] if cfg else default

class Colorer(object):
    '''
    Simple class that uses Pygments library to provide colorized
    output (full HTML) for diffs.
    '''
    def __init__(self):
        if pygments_available:
            self.formatter = HtmlFormatter(linenos=True, full=True)
            self.lexerobj  = DiffLexer()

    def formatDiff(self,data=None):
        '''
        Format diff
        '''
        self.data = data
        if self.data:
            try:
                self.result = highlight(self.data, self.lexerobj,
                    self.formatter)
            except:
                self.result = data
        return self.result

    def colorizeFile(self, fname=None):
        '''
        Colorizes input file. Result is HTML.
        '''
        if fname and os.path.exists(fname):
            _f = open(fname, 'r+b')
            _data = _f.read()
            _f.close()
            return self.formatDiff(_data)
        else:
            return None

class PrettyHTML(object):
    '''
    Simple class to make 'git show' message look prettier
    '''
    def __init__(self):
        self.keywords = ['commit', 'Author:', 'Date:']
        # If True all next messages are not checked against keywords
        self.keywords_trigger = False
        # Contains additional tags before the commit message
        self.extra_tags = ''

    def make_bold(self, keyword, line):
        '''
        Makes text bold
        '''
        if (re_search(keyword, line) != None) and \
            (self.keywords_trigger == False):
            if re_search(':', keyword) == None:
                replacement = '%s:' % keyword
            else:
                replacement = keyword
            line = line.replace(keyword, '<b>%s</b>' % replacement)
            line = "<br>%s" % line
        return line

    def convert(self, line):
        '''
        Convert 'git show' keywords
        '''
        replacements = 0
        for keyword in self.keywords:
            line_orig = line
            line = self.make_bold(keyword, line)
            if line != line_orig:
                replacements += 1
        # No replacements were made, assume we have commit message
        if replacements == 0:
            if self.keywords_trigger == False:
                self.keywords_trigger = True
                self.extra_tags = '<br>'
            else:
                # Only on-change lines should have extra tags
                self.extra_tags = ''
            line = '%s<br><b>%s</b>' % (self.extra_tags, line)
        return line


class Mail(object):
    '''
    Simple class for notifications via SMTP
    '''
    def __init__(self, smtp_host, smtp_port, smtp_login,
        smtp_password, smtp_usessl):

        self.smtp_host = smtp_host
        self.smtp_port = smtp_port
        self.smtp_login = smtp_login
        self.smtp_password = smtp_password
        self.smtp_usessl = smtp_usessl
        # Create message container
        # The correct MIME type is multipart/alternative.
        self.msg = MIMEMultipart('alternative')


    def addHeader(self, header, value, header_append=False):
        '''
        Adds message header
        '''
        # Verify presence of header
        if self.msg[header]:
            # Header already set, look out for recepient duplicates!
            if not header_append:
                return False
            del self.msg[header]
        # Set message header
        self.msg[header] = value
        return True

    def addPart(self, content_type, content, encoding=None):
        '''
        Adds message part
        '''
        if encoding:
            # Use specified encoding
            part = MIMEText(content, content_type, encoding)
        else:
            # Fallback to us-ascii
            part = MIMEText(content, content_type)
        return part

    def attach(self, part):
        '''
        Attach message part
        '''
        self.msg.attach(part)

    def attachHtml(self, content):
        '''
        Attach HTML message
        '''
        part = self.addPart('html', content, 'utf8')
        self.attach(part)

    def attachText(self, content):
        '''
        Attach text message
        '''
        part = self.addPart('plain', content)
        self.attach(part)

    def getMessage(self):
        '''
        Return whole message (so far)
        '''
        return self.msg

    def send(self, smtp_sender, smtp_mailinglist, smtp_data):
        '''
        Send email via SMTP
        '''
        log("Sending email to %s" % smtp_mailinglist)
        self.connection = smtplib.SMTP(self.smtp_host)
        try:
            # identify ourselves, prompting server for supported features
            self.connection.ehlo()

            # Encrypt connection if both server supports it
            # and self.smtp_usessl is True
            if self.connection.has_extn('STARTTLS') and self.smtp_usessl:
                self.connection.starttls()
                # re-identify ourselves over TLS connection
                self.connection.ehlo()

            # Enable SMTP AUTH if both self.smtp_login and
            # self.smtp_password are not empty.
            if self.smtp_login and self.smtp_password:
                self.connection.login(self.smtp_login, self.smtp_password)

            # Send message
            self.connection.sendmail(smtp_sender, smtp_mailinglist, smtp_data)
        except:
            # Status of message: delivery failed
            return False
        finally:
            self.connection.quit()
        # Status of message: delivery successful
        return True

class MailWrapper(object):
    '''
    MailWrapper class provides high level interface to Mail class
    '''
    def __init__(self, mail_object):
        self.mail = mail_object
        self.text_message = ''
        self.html_message = '<html>\n'

    def init(self, text='', html='<html>\n'):
        '''
        Start with reasonable defaults.
        '''
        self.text_message = text
        self.html_message = html

    def sendFile(self, out, fname):
        '''
        Send file contents via SMTP
        '''
        out.close()
        if Config.debug:
            for line in open(fname):
                print "    |", line,
            print ""
        else:
            _f = open(fname, 'r+b')
            _data = _f.read()
            _f.close()
            self.mail.send(Config.sender, Config.mailinglist, _data)

    def generateMailHeader(self, subject):
        '''
        Generates mail header
        '''
        # TODO: This function should be called only once during run.
        repo = _getRepo()
        # Reply-To equals to sender, if not set.
        replyto = 'Reply-To: %s\n' % \
            Config.replyto if Config.replyto else Config.sender
        if Config.altsubject:
            subject = ('Repository: %s Branch: %s ' % \
                (re_sub('ssh://(.+)/', '',repo), subject))

        # Set message headers
        self.mail.addHeader('From', Config.sender)
        self.mail.addHeader('To', Config.mailinglist)
        # Allow only 'Subject' header replacement.
        self.mail.addHeader('Subject',
            Config.emailprefix + subject, header_append=True)
        self.mail.addHeader('Reply-To', replyto)
        self.mail.addHeader('X-Git-Repository', repo)
        self.mail.addHeader('X-Mailer', Name + ' ' + VERSION)


    def addTag(self, key, value):
        '''
        Adds message tag
        '''
        if Config.colordiff:
            formatted = '<br><b>%-11s:</b> %s' % (key, value)
            self.addLine(formatted, html_only=True, start_br=False)
        else:
            formatted = '%-11s: %s' % (key, value)
            self.addLine(formatted, text_only=True)

    def addLine(self, line, text_only=False, html_only=False, start_br=True):
        '''
        Adds message line
        '''
        if text_only:
            self.text_message += line
            return
        if html_only:
            if Config.colordiff:
                if start_br:
                    self.html_message += '<br>%s' % line
                else:
                    self.html_message += line
            return
        # TODO: DRY!!!
        self.text_message += line
        if Config.colordiff:
            if start_br:
                self.html_message += '<br>%s' % line
            else:
                self.html_message += line

    def getMessage(self):
        '''
        Returns whole message
        '''
        # Message parts should be always attached before returning the message.
        self.mail.attachText(self.text_message)
        if Config.colordiff:
            self.mail.attachHtml(self.html_message)
        return self.mail.getMessage()


def log(msg):
    print >>Config.log, "%s - %s" % (time.asctime(), msg)

def error(msg):
    log("Error: %s" % msg)
    sys.exit(1)

def git(args, stdout_to=subprocess.PIPE, all=False):
    if isinstance(args, tuple) or isinstance(args, list):
        args = " ".join(args)

    try:
        if Config.debug:
            print >>sys.stderr, "> git " + args
    except NameError:
        # Config may not be defined yet.
        pass

    try:
        child = subprocess.Popen("git " + args, shell=True, stdin=None,
            stdout=stdout_to, stderr=subprocess.PIPE)
        (stdout, stderr) = child.communicate()
    except OSError, e:
        error("cannot start git: %s" % str(e))

    if child.returncode != 0 and stderr:
        msg = ": %s" % stderr if stderr else ""
        error("git child failed with exit code %d%s" % (child.returncode, msg))

    if stdout_to != subprocess.PIPE:
        return []

    if not all:
        return [line.strip() for line in stdout.split("\n") if line]
    else:
        return stdout.split("\n")

def getHeads(state):
    for (rev, head) in [head.split() for head in git("show-ref --heads")]:
        if head.startswith("refs/heads/"):
            head = head[11:]

        state.heads[head] = rev

def getTags(state):
    for (rev, tag) in [head.split() for head in git("show-ref --tags")]:
        # We are only interested in annotaged tags.
        type = git("cat-file -t %s" % rev)[0]

        if type == "tag":
            if tag.startswith("refs/tags/"):
                tag= tag[10:]

            state.tags[tag] = rev

def getReachableRefs(state):
    for rev in git(["rev-list"] + state.heads.keys() + state.tags.keys()):
        state.revs.add(rev)

def getCurrent():
    state = State()
    getHeads(state)
    getTags(state)
    getReachableRefs(state)

    return state

Tmps = []

def makeTmp():
    global Tmps

    (fd, fname) = tempfile.mkstemp(prefix="%s-" % Name, suffix=".tmp")
    Tmps += [fname]

    return (os.fdopen(fd, "w"), fname)

def deleteTmps():
    for tmp in Tmps:
        os.unlink(tmp)

def _getRepo():
    repo = Config.repouri
    if not repo:
        if gitolite:
            # Gitolite version.
            repo = "ssh://%s@%s/%s" % (whoami, Config.hostname,
                os.path.basename(os.getcwd()))
        else:
            # Standard version.
            repo = "ssh://%s/%s" % (Config.hostname,
                os.path.basename(os.getcwd()))
        if repo.endswith(".git"):
            repo = repo[0:-4]
    return repo


def entryAdded(key, value, rev):
    log("New %s %s" % (key, value))
    (out, fname) = makeTmp()

    # Start with empty message
    message.init()
    message.generateMailHeader("%s '%s' created" % (key, value))

    message.addTag("New %s" % key, value)
    message.addTag("Referencing", rev)

    # print whole message to file
    print >>out, message.getMessage()
    message.sendFile(out, fname)

def entryDeleted(key, value):
    log("Deleted %s %s" % (key, value))
    (out, fname) = makeTmp()

    # Start with empty message
    message.init()
    message.generateMailHeader("%s '%s' deleted" % (key, value))

    message.addTag("Deleted %s" % key, value)

    # print whole message to file
    print >>out, message.getMessage()
    message.sendFile(out, fname)

# Sends a mail for a notification consistent of two parts: (1) the output of a
# show command, and (2) the output of a diff command.
def sendChangeMail(rev, subject, heads, show_cmd, diff_cmd):
    repo = _getRepo()
    # The 'git show' prettifier
    prettyhtml = PrettyHTML()
    # Start with empty message
    message.init()
    message.generateMailHeader(subject)
    (out, fname) = makeTmp()
    #
    message.addTag("Repository", repo)

    multi = "es" if len(heads) > 1 else ""
    heads = ",".join(heads)

    message.addTag("On branch%s" % multi, heads)

    if Config.link:
        url = Config.link.replace("%s", rev)
        message.addTag("Link", url)

    footer = ""
    show = git(show_cmd)

    for line in show:
        if NoDiff in line:
            break

        if NoMail in line:
            return

    else:
        (tmp, tname) = makeTmp()
        diff = git(diff_cmd, stdout_to=tmp)
        tmp.close()

        size = os.path.getsize(tname)
        if size > Config.maxdiffsize:
            footer = "\nDiff suppressed because of size.\n \
                To see it, use:\n\n    git %s" % diff_cmd
            tname = None

    message.addLine(Separator, text_only=True)
    # Use nice <hr> in html mode
    message.addLine(Separhtml, html_only=True)

    for line in git(show_cmd, all=True):
        if line == "---":
            message.addLine(Separator, text_only=True)
            message.addLine(Separhtml, html_only=True)
        else:
            message.addLine(line + "\n", text_only=True)
            message.addLine(prettyhtml.convert(line),
                html_only=True, start_br=False)

    message.addLine(Separator, text_only=True)
    message.addLine(Separhtml, html_only=True)

    # Text only, read diff from file
    if tname:
        for line in open(tname):
            message.addLine(line, text_only=True)

    # HTML only, read and parse diff
    if Config.colordiff and tname:
        colorer = Colorer()
        message.addLine(colorer.colorizeFile(tname),
            html_only=True, start_br=False)

    message.addLine(footer, text_only=True)
    message.addLine(footer.replace("\n", "<br>\n"), html_only=True)

    if Config.debug:
        message.addLine("-- ", text_only=True)
        # Use nice <hr> in html mode
        message.addLine(Separhtml, html_only=True)
        # Both text and html
        message.addLine("debug: show_cmd = git %s" % show_cmd)
        message.addLine("debug: diff_cmd = git %s" % diff_cmd)

    # print whole message to file
    print >>out, message.getMessage()
    message.sendFile(out, fname)

# Sends notification for a specific revision.
def commit(current, rev, force=False, subject_head=None):
    if rev in current.reported and not force:
        # Already reported in this run of the script.
        log("Flagged revision %s for notification, \
            but already reported this time" % rev)
        return

    log("New revision %s" % rev)
    current.reported.add(rev)

    heads = [head.split()[-1] for head in git("branch --contains=%s" % rev)]
    if not subject_head:
        subject_head = ",".join(heads)

    merge_diff = "--cc"

    for head in heads:
        if head in Config.allchanges or head in Config.mergediffs:
            merge_diff = "-m"

    subject = git("show '--pretty=format:%%s (%%h)' -s %s" % rev)
    subject = "%s: %s" % (subject_head, subject[0])

    show_cmd = "show -s --no-color --find-copies-harder \
        --pretty=medium %s" % rev
    diff_cmd = "diff-tree --patch-with-stat --no-color --find-copies-harder \
        --ignore-space-at-eol %s %s" % (merge_diff, rev)

    sendChangeMail(rev, subject, heads, show_cmd, diff_cmd)

# Sends a diff between two revisions.
#
# Only used in manual mode now.
def diff(head, first, last):
    # We record a pseudo-revision to avoid sending the same diff twice.
    rev = "%s-%s" % (head, last)
    if not rev in current.diffs:
        log("New diff revision %s" % rev)
        current.diffs.add(rev)

    log("Diffing %s..%s" % (first, last))

    subject = git("show '--pretty=format:%%s (%%h)' -s %s" % last)
    subject = "%s diff: %s" % (head, subject[0])

    heads = [head]

    show_cmd = "show -s --no-color --find-copies-harder \
        --pretty=medium %s" % last
    diff_cmd = "diff --patch-with-stat -m --no-color --find-copies-harder \
        --ignore-space-at-eol %s %s" % (first, last)

    sendChangeMail(last, subject, heads, show_cmd, diff_cmd)

# Sends pair-wise diffs for a path of revisions. Also records all revision on
# the path as seen.
#
# Only used in manual mode now.
def diffPath(head, revs):
    last = None

    for rev in revs:
        if last:
            diff(head, last, rev)
        last = rev

# Sends a commit notifications for a set of revisions.
def reportPath(current, revs, force=False, subject_head=None):
    if not revs:
        return

    # Sort updates by time.
    revs = git("rev-list --no-walk --reverse --date-order %s" % " ".join(revs))

    for rev in revs:
        commit(current, rev, force=force, subject_head=subject_head)

# Sends a summary mail for a set of revisions.
def headMoved(head, path):
    log("Head moved: %s -> %s" % (head, path[-1]))
    (out, fname) = makeTmp()

    subject = git("show '--pretty=format:%%s (%%h)' -s %s" % path[-1])

    # Start with empty message
    message.init()
    message.generateMailHeader("%s's head updated: %s" % (head, subject[0]))

    message.addLine("Branch '%s' now includes:" % head)
    message.addLine("")

    for rev in path:
        message.addLine("    " +
            str(git("show -s --pretty=oneline --abbrev-commit %s" % rev)[0]))

    # print whole message to file
    print >>out, message.getMessage()
    message.sendFile(out, fname)

Config = GitConfig(sys.argv[1:])

mail = Mail(Config.smtpserver, Config.smtpport,
            Config.smtplogin, Config.smtppassword, Config.smtpssl)
#
message = MailWrapper(mail)

log("Running for %s" % os.getcwd())

if Config.debug:
    for (name, arg, default, help) in Options:
        print >>sys.stderr, "[Option %s: %s]" % (name, Config.__dict__[name])

cache = State()

if os.path.exists(CacheFile):
    cache.readFrom(CacheFile)
    report = (not Config.updateonly)
else:
    log("Initial run. Not generating any mails, just recording current state.")
    report = False

current = getCurrent()

if Config.diff:
    # Manual diff mode. The argument must be of the form "[old-rev..]new-rev".
    path = [rev.strip() for rev in Config.diff.split("..")]
    if len(path) == 1:
        path = ("%s~2" % path[0], path[0]) # sic! ~2.
    else:
        path = ("%s~1" % path[0], path[1])

    revs = git(["rev-list", "--reverse --date-order", path[1], "^%s" % path[0]])

    diffPath("<manual-diff>", revs)

    sys.exit(0)

if Config.manual:
    # Manual report mode. The argument must be of the form "[old-rev..]new-rev".
    path = [rev.strip() for rev in Config.manual.split("..")]
    if len(path) == 1:
        path = ("%s~1" % path[0], path[0])

    revs = git(["rev-list", "--reverse --date-order", path[1], "^%s" % path[0]])
    reportPath(current, revs, force=True)

    sys.exit(0)

if report:
    # Check for changes to the set of heads.
    old = set(cache.heads.keys())
    new = set(current.heads.keys())

    for head in (new - old):
        entryAdded("branch", head, current.heads[head])

    for head in (old - new):
        entryDeleted("branch", head)

    stable_heads = new & old
    Config.allchanges = Config.allchanges & stable_heads

    # Check tags.
    old = set(cache.tags.keys())
    new = set(current.tags.keys())

    for tag in (new - old):
        entryAdded("tag", tag, current.tags[tag])

    for tag in (old - new):
        entryDeleted("tag", tag)

    # Notify for unreported commits.
    old = set(cache.revs)
    new = set(current.revs)
    new_revs = (new - old)
    reportPath(current, new_revs)

    # Do reports for the heads we want to see everything for.
    for head in stable_heads:
        old_rev = cache.heads[head]
        new_rev = current.heads[head]
        path = git(["rev-list",
            "--reverse --date-order", new_rev, "^%s" % old_rev])

        if head in Config.allchanges:
            # Want to see all commits for this head, even if already reported
            # in the past for some other. So we record these separately.
            reportPath(current, path, subject_head=head)
        else:
            # Just send a summary for heads that now include some new stuff.
            if len(set(path) - new_revs):
                headMoved(head, path)

if not Config.noupdate:
    current.writeTo(CacheFile)

deleteTmps()

