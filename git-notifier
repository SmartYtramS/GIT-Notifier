#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
This is a fork of ICIR.org git-notifier that implements colorized diff support
plus some other nice things.
Please refer to https://github.com/tb0hdan/GIT-Notifier for more detail.
'''

# TODO: Test necessity of this.
from __future__ import with_statement

# pylint: disable=C0103,C0302
import optparse
import os
import shutil
import socket
import sys
import subprocess
import tempfile
import logging
import smtplib
from time import asctime as time_asctime
from urllib import urlopen as urllib_urlopen
from re import sub as re_sub, search as re_search, split as re_split
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

try:
    eval("1 if True else 2")
except SyntaxError:
    raise ImportError(u'This software requires ternary support.')

try:
    import pygments
    from pygments import highlight
    from pygments.lexers import DiffLexer # pylint: disable=E0611
    from pygments.formatters import HtmlFormatter # pylint: disable=E0611
    # pylint: disable=E0611
    from pygments.styles import get_style_by_name, STYLE_MAP
    pygments_available = True
except ImportError:
    pygments_available = False

if pygments_available:
    if float(pygments.__version__) < 0.7:
        logging.warning(u'You have an outdated Pygments version installed.')
        logging.warning(u'Disabling Pygments support.')
        pygments_available = False

__license__ = 'BSD'
__version__ = '0.4-3'
UpdateURL   = 'https://raw.github.com/tb0hdan/GIT-Notifier/master/git-notifier'
ProjectURL  = 'https://github.com/tb0hdan/GIT-Notifier'
Name        = 'git-notifier'
CacheFile   = '.%s.dat' % Name
Separator   = '\n>%s\n' % ('-' * 62)
Separhtml   = '<hr>'
NoDiff      = '[nodiff]'
NoMail      = '[nomail]'

gitolite = 'GL_USER' in os.environ
# Git via Apache/DAV fix
try:
    whoami = os.environ['LOGNAME']
except KeyError:
    import getpass
    whoami =  getpass.getuser()
sender = os.environ['GL_USER'] if gitolite else whoami

Options = [
    # Name, argument, default, help,
    # NOTE: --version, --help are provided by optparse library itself.
    ("allchanges", True, set(),
     "branches for which *all* changes are to be reported"),
    ("altsubject", False, False,
     "enables alternative subject with repository name"),
    ("debug", False, False, "enable debug output"),
    ("diff", True, None, "mail out diffs between two revisions"),
    ("emailprefix", True, "[git]", "Subject prefix for mails"),
    ("disablefooter", False, False,
    "enables page footer for all commit messages"),
    ("digest", False, False,
    "Send multiple commit notification as single message"),
    ("hostname", True, socket.gethostname(),
     "host where the repository is hosted"),
    ("log", True, "%s.log" % Name, "set log output"),
    ("mailinglist", True, whoami, "destination address for mails"),
    ("smtpserver", True, 'localhost', "tells SMTP server to use, host only"),
    ("smtpport", True, 25, "sets SMTP port for SMTP server"),
    ("smtplogin", True, None, "sets login for SMTP AUTH"),
    ("smtppassword", True, None, "sets password for SMTP AUTH"),
    ("smtpssl", False, False, "enables SSL for SMTP"),
    ("manual", True, None, "notify for a manually given set of revisions"),
    ("maxdiffsize", True, 50, "limit the size of diffs in mails (KB)"),
    ("colordiff", False, False, "colorize diffs using pygments library"),
    ("colorstyle", True, "tango",
    "defines style for colordiff option"),
    ("noupdate", False, False, "do not update the state file"),
    ("repouri", True, None, "full URI for the repository"),
    ("sender", True, sender, "sender address for mails"),
    ("link", True, None,
     "Link to insert into mail, %s will be replaced with revision"),
    ("updateonly", False, False, "update state file only, no mails"),
    ("upgrade", False, False, "upgrade %s installation" % Name),
    ("users", True, None, "location of a user-to-email mapping file"),
    ("replyto", True, None, "email address for reply-to header"),
    ("mergediffs", True, set(),
     "branches for which complete merge diffs are to be included"),
    ]

class State(object):
    '''
    State class
    '''
    def __init__(self):
        self.clear()

    def clear(self):
        '''
        Clear data structures
        '''
        self.heads = {}
        self.tags = {}
        self.revs = set()
        self.diffs = set()

        self.reported = set() # Revs reported this run so far.

    def writeTo(self, file):
        '''
        Write to cache file
        '''
        if os.path.exists(CacheFile):
            try:
                shutil.move(CacheFile, CacheFile + ".bak")
            except IOError:
                pass

        out = open(file, "w")

        for (head, ref) in self.heads.items():
            print >> out, "head", head, ref

        for (tag, ref) in self.tags.items():
            print >> out, "tag", tag, ref

        for rev in self.revs:
            print >> out, "rev", rev


    def readFrom(self, file):
        '''
        Read from cache file
        '''
        self.clear()

        for line in open(file):

            line = line.strip()
            if not line or line.startswith("#"):
                continue

            m = line.split()

            if len(m) == 3:
                (type, key, val) = (m[0], m[1], m[2])
            else:
                # No heads.
                (type, key, val) = (m[0], m[1], "")

            if type == "head":
                self.heads[key] = val

            elif type == "tag":
                self.tags[key] = val

            elif type == "rev":
                self.revs.add(key)

            elif type == "diff":
                self.diffs.add(key)

            else:
                utilities.error(u'unknown type %s in cache file' % type)

class GitConfig(object):
    '''
    GitConfig class
    '''
    def __init__(self, args):
        self.parseArgs(args)
        # KBytes to bytes.
        self.maxdiffsize *= 1024 # pylint: disable=E1101


        if self.allchanges and not isinstance(self.allchanges, set):
            # pylint: disable=E1101
            self.allchanges = \
                set([head.strip() for head in self.allchanges.split(",")])

        if self.mergediffs and not isinstance(self.mergediffs, set):
            # pylint: disable=E1101
            self.mergediffs = \
                set([head.strip() for head in self.mergediffs.split(",")])

        if not self.debug: # pylint: disable=E1101
            self.log = open(self.log, "a")
        else:
            self.log = sys.stderr

        if not self.users and "GL_ADMINDIR" in os.environ:
            users = os.path.join(os.environ["GL_ADMINDIR"], "conf/sender.cfg")
            if os.path.exists(users):
                self.users = users

        self.readUsers()

    def parseArgs(self, args):
        '''
        Parse command line arguments
        '''
        parser = optparse.OptionParser(version=__version__)

        for (name, arg, default, help) in Options:
            defval = self._git_config(name, default)

            if isinstance(default, int):
                defval = int(defval)

            if not arg:
                defval = bool(defval)

            if not arg:
                action = "store_true" if not default else "store_false"
                parser.add_option("--%s" % name, action=action, dest=name,
                    default=defval, help=help)

            else:
                type = "string" if not isinstance(default, int) else "int"
                parser.add_option("--%s" % name, action="store", type=type,
                    default=defval, dest=name, help=help)

        (options, args) = parser.parse_args(args)

        if len(args) != 0:
            parser.error(u'incorrect number of arguments')

        for (name, arg, default, help) in Options:
            self.__dict__[name] = options.__dict__[name]

    def readUsers(self):
        '''
        Read users from configuration file
        '''
        if self.users and os.path.exists(self.users):
            for line in open(self.users):
                line = line.strip()
                if not line or line.startswith("#"):
                    continue

                m = line.split()

                if self.sender == m[0]:
                    self.sender = " ".join(m[1:])
                    break

    def _git_config(self, key, default):
        '''
        Return git configuration
        '''
        cfg = gitutilities.git(["config hooks.%s" % key])
        return cfg[0] if cfg else default

class GitUtilities(object):
    def __init__(self):
        self.activeRepo = None

    def git(self, args, stdout_to=subprocess.PIPE, all=False):
        '''
        Provides pythonic interface to git executable
        '''
        if isinstance(args, tuple) or isinstance(args, list):
            args = " ".join(args)

        try:
            if Config.debug: # pylint: disable=E1101
                logging.error(u'> git %s' % str(args))
        except NameError:
            # Config may not be defined yet.
            pass

        try:
            child = subprocess.Popen("git " + args, shell=True, stdin=None,
                stdout=stdout_to, stderr=subprocess.PIPE)
            (stdout, stderr) = child.communicate()
        except OSError, __error:
            utilities.error(u'cannot start git: %s' % repr(__error))

        if child.returncode != 0 and stderr:
            msg = ": %s" % stderr if stderr else ""
            utilities.error(u'git child failed with exit code %d%s' % \
                (child.returncode, msg))

        if stdout_to != subprocess.PIPE:
            return []

        if not all:
            # pylint: disable=E1103
            return [line.strip() for line in stdout.split("\n") if line]
        else:
            # pylint: disable=E1103
            return stdout.split("\n")

    def getHeads(self, state):
        '''
        Retrieves information about repository heads
        '''
        for (rev, head) in [head.split() for head in \
            self.git("show-ref --heads")]:
            if head.startswith("refs/heads/"):
                head = head[11:]

            state.heads[head] = rev
        return state

    def getTags(self, state):
        '''
        Retrieves information about repository tags
        '''
        for (rev, tag) in [head.split() for head in \
            self.git("show-ref --tags")]:
            # We are only interested in annotaged tags.
            tag_type = self.git("cat-file -t %s" % rev)[0]

            if tag_type == "tag":
                if tag.startswith("refs/tags/"):
                    tag = tag[10:]

                state.tags[tag] = rev
        return state

    def getReachableRefs(self, state):
        '''
        Retrieves information about reachable repository revisions.
        Result is an array.
        '''
        for rev in self.git(["rev-list"] + state.heads.keys() \
            + state.tags.keys()):
            state.revs.add(rev)
        return state

    def getCurrent(self):
        '''
        Read current state from file.
        '''
        self.state = State()
        self.state = self.getHeads(self.state)
        self.state = self.getTags(self.state)
        self.state = self.getReachableRefs(self.state)

        return self.state

    def getRepo(self):
        '''
        Retrieve repository path
        '''
        if self.activeRepo:
            return self.activeRepo
        repo = Config.repouri # pylint: disable=E1101
        if not repo:
            if gitolite:
                # Gitolite version.
                # pylint: disable=E1101
                repo = "ssh://%s@%s/%s" % (whoami, Config.hostname,
                    os.path.basename(os.getcwd()))
            else:
                # Standard version.
                # pylint: disable=E1101
                repo = "ssh://%s/%s" % (Config.hostname,
                    os.path.basename(os.getcwd()))
            if repo.endswith(".git"):
                repo = repo[0:-4]
        self.activeRepo = repo
        return self.activeRepo

    def entryAdded(self, key, value, rev):
        '''
        Hook for adding an entry
        '''
        utilities.log("New %s %s" % (key, value))
        (out, fname) = utilities.makeTmp()

        # Initialize message
        message.init()
        message.generateMailHeader("%s '%s' created" % (key, value))

        message.addTag("New %s" % key, value)
        message.addTag("Referencing", rev)

        # print whole message to file
        print >> out, message.getMessage()
        message.sendFile(out, fname)

    def entryDeleted(self, key, value):
        '''
        Hook for deleting an entry
        '''
        utilities.log("Deleted %s %s" % (key, value))
        (out, fname) = utilities.makeTmp()

        # Initialize message
        message.init()
        message.generateMailHeader("%s '%s' deleted" % (key, value))

        message.addTag("Deleted %s" % key, value)

        # print whole message to file
        print >> out, message.getMessage()
        message.sendFile(out, fname)

    def sendChangeMail(self, rev, subject, heads, show_cmd, diff_cmd):
        '''
        Sends a mail for a notification consistent of two parts:
        (1) the output of a show command,
        (2) the output of a diff command.
        '''
        # The 'git show' prettifier
        prettyhtml = PrettyHTML(subject='Git commit %s' % subject[-9:])
        # Initialize message
        message.init()
        message.generateMailHeader(subject)
        (out, fname) = utilities.makeTmp()
        #
        message.addTag("Repository", self.getRepo())

        multi = "es" if len(heads) > 1 else ""
        heads = ",".join(heads)

        message.addTag("On branch%s" % multi, heads)

        if Config.link: # pylint: disable=E1101
            url = Config.link.replace("%s", rev) # pylint: disable=E1101
            message.addTag("Link", url)

        footer = ""
        show = self.git(show_cmd)

        for line in show:
            if NoDiff in line:
                break

            if NoMail in line:
                return

        else:
            (tmp, tname) = utilities.makeTmp()
            # TODO: Find better place for this
            diff = self.git(diff_cmd, stdout_to=tmp)
            tmp.close()

            size = os.path.getsize(tname)
            if size > Config.maxdiffsize: # pylint: disable=E1101
                footer = "\nDiff suppressed because of size.\n \
                    To see it, use:\n\n    git %s" % diff_cmd
                tname = None

        message.addLine(Separator, text_only=True)
        # Use nice <hr> in html mode
        message.addLine(Separhtml, html_only=True)

        for line in self.git(show_cmd, all=True):
            if line == "---":
                message.addLine(Separator, text_only=True)
                message.addLine(Separhtml, html_only=True)
            else:
                message.addLine(line + "\n", text_only=True)
                message.addLine(prettyhtml.convert(line) + "\n",
                    html_only=True, start_br=False)

        message.addLine(Separator, text_only=True)
        message.addLine(Separhtml, html_only=True)

        # Text only, read diff from file
        if tname:
            for line in open(tname):
                message.addLine(line, text_only=True)

        # HTML only, read and parse diff
        if Config.colordiff and tname: # pylint: disable=E1101
            colorer = Colorer()
            message.addLine('\n', html_only=True, start_br=False)
            message.addLine(colorer.colorizeFile(tname,
                key_start='diff\ --git'),
                html_only=True, start_br=False)

        message.addLine(footer, text_only=True)
        message.addLine(footer.replace("\n", "<br>\n"), html_only=True)

        if Config.debug: # pylint: disable=E1101
            message.addLine("-- ", text_only=True)
            # Use nice <hr> in html mode
            message.addLine(Separhtml, html_only=True)
            # Both text and html
            message.addLine("debug: show_cmd = git %s" % show_cmd)
            message.addLine("debug: diff_cmd = git %s" % diff_cmd)

        # print whole message to file
        print >> out, message.getMessage()
        message.sendFile(out, fname)

    def commit(self, current, rev, force=False, subject_head=None):
        '''
        Sends notification for a specific revision.
        '''
        if rev in current.reported and not force:
            # Already reported in this run of the script.
            utilities.log(u'Flagged revision %s for notification, \
                but already reported this time' % rev)
            return

        utilities.log("New revision %s" % rev)
        current.reported.add(rev)

        heads = [head.split()[-1] for head in \
        self.git("branch --contains=%s" % rev)]
        if not subject_head:
            subject_head = ",".join(heads)

        merge_diff = "--cc"

        for head in heads:
            if head in Config.allchanges or head in Config.mergediffs:
                merge_diff = "-m"

        subject = self.git("show '--pretty=format:%%s (%%h)' -s %s" % rev)
        subject = "%s: %s" % (subject_head, subject[0])

        show_cmd = "show -s --no-color --find-copies-harder \
            --pretty=medium %s" % rev
        diff_cmd = "diff-tree --patch-with-stat --no-color \
            --find-copies-harder \
            --ignore-space-at-eol %s %s" % (merge_diff, rev)

        self.sendChangeMail(rev, subject, heads, show_cmd, diff_cmd)

    def diff(self, head, first, last):
        '''
        Sends a diff between two revisions.
        Only used in manual mode now.
        '''
        current = self.getCurrent()
        # We record a pseudo-revision to avoid sending the same diff twice.
        rev = "%s-%s" % (head, last)
        if not rev in current.diffs:
            utilities.log(u'New diff revision %s' % rev)
            current.diffs.add(rev)

        utilities.log("Diffing %s..%s" % (first, last))

        subject = self.git("show '--pretty=format:%%s (%%h)' -s %s" % last)
        subject = "%s diff: %s" % (head, subject[0])

        heads = [head]

        show_cmd = "show -s --no-color --find-copies-harder \
            --pretty=medium %s" % last
        diff_cmd = "diff --patch-with-stat -m --no-color --find-copies-harder \
            --ignore-space-at-eol %s %s" % (first, last)

        self.sendChangeMail(last, subject, heads, show_cmd, diff_cmd)

    def diffPath(self, head, revs):
        '''
        Sends pair-wise diffs for a path of revisions.
        Also records all revision on the path as seen.
        Only used in manual mode now.
        '''
        last = None

        for rev in revs:
            if last:
                self.diff(head, last, rev)
            last = rev

    def reportPath(self, current, revs, force=False, subject_head=None):
        '''
        Sends a commit notifications for a set of revisions.
        '''
        if not revs:
            return

        # Sort updates by time.
        revs = self.git("rev-list --no-walk --reverse \
            --date-order %s" % " ".join(revs))

        if len(revs) > 1:
            message.setMultiCommit(True)

        for rev in revs:
            # Get last revision
            if rev == revs[len(revs)-1]:
                message.setLastCommit(True)
            self.commit(current, rev, force=force, subject_head=subject_head)

    def headMoved(self, head, path):
        '''
        Sends a summary mail for a set of revisions.
        '''
        utilities.log("Head moved: %s -> %s" % (head, path[-1]))
        (out, fname) = utilities.makeTmp()

        subject = self.git("show '--pretty=format:%%s (%%h)' -s %s" % path[-1])

        # Initialize message
        message.init()
        message.generateMailHeader("%s's head updated: %s" % (head, subject[0]))

        message.addLine("Branch '%s' now includes:" % head)
        message.addLine("")

        for rev in path:
            message.addLine("    " +
                str(self.git("show -s --pretty=oneline \
                    --abbrev-commit %s" % rev)[0]))

        # print whole message to file
        print >> out, message.getMessage()
        message.sendFile(out, fname)

class Colorer(object):
    '''
    Simple class that uses Pygments library to provide colorized
    output (full HTML) for diffs.
    '''
    def __init__(self):
        self.result = ''
        if pygments_available:
            # pylint: disable=E1101
            if not Config.colorstyle in STYLE_MAP:
                logging.warning(u'Specified color style not available.')
                logging.warning(u'Using default instead.')
                self.style = 'default'
            else:
                # pylint: disable=E1101
                self.style = Config.colorstyle
            self.formatter = HtmlFormatter(linenos=True, full=True,
                encoding="utf-8", style=get_style_by_name(self.style))
            self.lexerobj  = DiffLexer()

    def formatDiff(self, data=None):
        '''
        Format diff
        '''
        self.data = data
        if self.data:
            try:
                self.result = highlight(self.data, self.lexerobj,
                    self.formatter)
            except:
                self.result = self.data
        return self.result

    def colorizeFile(self, fname=None, key_start=None, key_end=None):
        '''
        Colorizes input file. Result is HTML.
        '''
        if fname and os.path.exists(fname):
            __data = utilities.readfile(fname)
            # We have data, good.
            if (key_start == None) and (key_end == None):
                return self.formatDiff(__data)
            else:
                # Since we have text file here such split works just fine.
                __trigger = False
                __result_data = __noformat_data = ''
                for line in __data.split('\n'):
                    if key_start and (re_search(key_start, line) != None):
                        __trigger = True
                    if key_end   and (re_search(key_end,   line) != None):
                        __trigger = False
                    if  __trigger:
                        __result_data += line + '\n'
                    else:
                        __noformat_data += line + '\n'
                __noformat_data ='<pre>%s</pre>' % __noformat_data
                __result_data = '%s\n%s' % (__noformat_data,
                        self.formatDiff(__result_data))
                return __result_data
        else:
            return None

class PrettyHTML(object):
    '''
    Simple class to make 'git show' message look prettier
    '''
    def __init__(self, subject=None):
        self.keywords = ['commit', 'Author:', 'Date:']
        # If True all next messages are not checked against keywords
        self.keywords_trigger = False
        # Contains additional tags before the commit message
        self.extra_tags = ''
        # Mailto subject part
        self.subject = subject
        if not self.subject:
            self.subject = 'Git commit'

    def transcode(self, line):
        '''
        Encodes characters to HTML
        '''
        self.line = line
        self.line = self.line.replace('<', '&lt;').replace('>', '&gt;')
        # Required for mailto subject encoding
        self.line = self.line.replace(' ', '%20')
        return self.line

    def make_bold(self, keyword, line):
        '''
        Makes text bold
        '''
        part1 = ''
        part2 = ''
        if (re_search(keyword, line) != None) and \
            (self.keywords_trigger == False):
            if re_search(':', keyword) == None:
                replacement = '%s:' % keyword
            else:
                replacement = keyword
            # commit replacement
            if (keyword in self.keywords) and (not replacement[:1].isupper()):
                replacement = replacement[0].upper() + replacement[1:]
            # git commit email
            if re_search('[A|a]uthor', keyword) != None:
                try:
                    part1 = re_split('<(.*)>', line)[0].strip()
                    part2 = re_split('<(.*)>', line)[1].strip()
                except:
                    logging.error("Broken email?")
                if (part1 != '') and (part2 != ''):
                    email = part2
                    uri = '<a href="mailto:%s?subject=%s">&lt;%s&gt;</a>' % \
                     (email, self.transcode(self.subject), email)
                    line = part1 + ' ' + uri
            line = line.replace(keyword, '<b>%s</b>' % replacement)
            line = "<br>%s" % line
        return line

    def convert(self, line):
        '''
        Convert 'git show' keywords
        '''
        replacements = 0
        for keyword in self.keywords:
            line_orig = line
            line = self.make_bold(keyword, line)
            if line != line_orig:
                replacements += 1
        # No replacements were made, assume we have commit message
        if replacements == 0:
            if self.keywords_trigger == False:
                self.keywords_trigger = True
                self.extra_tags = '<br>'
            else:
                # Only on-change lines should have extra tags
                self.extra_tags = ''
            line = '%s<br><b>%s</b>' % (self.extra_tags, line)
        return line

class Mail(object):
    '''
    Simple class for notifications via SMTP
    '''
    def __init__(self, cfg_obj):
        self.cfg_obj = cfg_obj
        # Create message container
        # The correct MIME type is multipart/alternative.
        self.msg = MIMEMultipart('alternative')

    def addHeader(self, header, value, header_append=False):
        '''
        Adds message header
        '''
        # Verify presence of header
        if self.msg[header]:
            # Header already set, look out for recepient duplicates!
            if not header_append:
                return False
            del self.msg[header]
        # Set message header
        self.msg[header] = value
        return True

    def addPart(self, content_type, content, encoding=None):
        '''
        Adds message part
        '''
        if encoding:
            # Use specified encoding
            part = MIMEText(content, content_type, encoding)
        else:
            # Fallback to us-ascii
            part = MIMEText(content, content_type)
        return part

    def attach(self, part):
        '''
        Attach message part
        '''
        self.msg.attach(part)

    def attachHtml(self, content):
        '''
        Attach HTML message
        '''
        part = self.addPart('html', content, 'utf8')
        self.attach(part)

    def attachText(self, content):
        '''
        Attach text message
        '''
        part = self.addPart('plain', content)
        self.attach(part)

    def getMessage(self):
        '''
        Return whole message (so far)
        '''
        return self.msg

    def send(self, smtp_sender, smtp_mailinglist, smtp_data):
        '''
        Send email via SMTP
        '''
        utilities.log("Sending email to %s" % smtp_mailinglist)
        try:
            self.connection = smtplib.SMTP(self.cfg_obj.smtpserver)
        except Exception as __error:
            logging.error(u'SMTPlib %s contacting server %s:%s' % (repr(__error),
                self.cfg_obj.smtpserver, self.cfg_obj.smtpport))
            logging.error(u'Message delivery failed.')
            return False
        try:
            # identify ourselves, prompting server for supported features
            self.connection.ehlo()

            # Encrypt connection if both server supports it
            # and self.smtp_usessl is True
            if self.connection.has_extn('STARTTLS') and self.cfg_obj.smtpssl:
                self.connection.starttls()
                # re-identify ourselves over TLS connection
                self.connection.ehlo()

            # Enable SMTP AUTH if both self.smtp_login and
            # self.smtp_password are not empty.
            if self.cfg_obj.smtplogin and self.cfg_obj.smtppassword:
                self.connection.login(self.cfg_obj.smtplogin, 
                    self.cfg_obj.smtppassword)

            # Send message
            self.connection.sendmail(smtp_sender, smtp_mailinglist, smtp_data)
        except:
            # Status of message: delivery failed
            return False
        finally:
            self.connection.quit()
        # Status of message: delivery successful
        return True

class MailWrapper(object):
    '''
    MailWrapper class provides high level interface to Mail class
    '''
    def __init__(self, mail, config):
        self.mail = mail
        self.cfg_obj = config
        self.isLastCommit = True
        self.text_message_defaults = ''
        self.text_message = self.text_message_defaults
        self.html_message_defaults = '<html>\n'
        self.html_message = self.html_message_defaults

    def init(self, text=None, html=None):
        '''
        Start with reasonable defaults.
        '''
        if text:
            self.text_message = text
        elif not self.cfg_obj.digest: # pylint: disable=E1101
            self.text_message = self.text_message_defaults
        if html:
            self.html_message = html
        elif not self.cfg_obj.digest: # pylint: disable=E1101
            self.html_message = self.html_message_defaults

    def sendFile(self, out, fname):
        '''
        Send file contents via SMTP
        '''
        out.close()
        if self.cfg_obj.debug: # pylint: disable=E1101
            for line in open(fname):
                print u'    |', line,
            print ''
        elif self.isLastCommit:
            _data = utilities.readfile(fname)
            # pylint: disable=E1101
            self.mail.send(self.cfg_obj.sender, 
                self.cfg_obj.mailinglist, _data)

    def generateMailHeader(self, subject):
        '''
        Generates mail header
        '''
        # Reply-To equals to sender, if not set.
        # pylint: disable=E1101
        replyto = 'Reply-To: %s\n' % \
            self.cfg_obj.replyto if self.cfg_obj.replyto else \
                self.cfg_obj.sender
        if self.cfg_obj.altsubject:
            subject = ('Repository: %s Branch: %s ' % \
                (re_sub('ssh://(.+)/', '',gitutilities.getRepo()), subject))

        # Set message headers
        self.mail.addHeader('From', self.cfg_obj.sender)
        self.mail.addHeader('To', self.cfg_obj.mailinglist)
        # Allow only 'Subject' header replacement.
        self.mail.addHeader('Subject',
            self.cfg_obj.emailprefix + subject, header_append=True)
        self.mail.addHeader('Reply-To', replyto)
        self.mail.addHeader('X-Git-Repository', gitutilities.getRepo())
        self.mail.addHeader('X-Mailer', Name + ' ' + __version__)

    def addTag(self, key, value):
        '''
        Adds message tag
        '''
        if self.cfg_obj.colordiff: # pylint: disable=E1101
            formatted = '<br><b>%-11s:</b> %s\n' % (key, value)
            self.addLine(formatted, html_only=True, start_br=False)
        else:
            formatted = '%-11s: %s' % (key, value)
            self.addLine(formatted, text_only=True)

    def __br_process(self, start_br, message, line):
        '''
        Internal method to stay DRY
        '''
        if start_br:
            message += '<br>%s' % line
        else:
            message += line
        return message

    def addLine(self, line, text_only=False, html_only=False, start_br=True):
        '''
        Adds message line
        '''
        if text_only:
            self.text_message += line
            return True
        if html_only:
            if self.cfg_obj.colordiff: # pylint: disable=E1101
                self.html_message = self.__br_process(start_br,
                    self.html_message,line)
            return True
        self.text_message += line
        if self.cfg_obj.colordiff: # pylint: disable=E1101
            self.html_message = self.__br_process(start_br,
                self.html_message, line)
        return True

    def setMultiCommit(self, isMultiCommit=False):
        '''
        Tells other methods in class that we have multiple commits.
        '''
        self.isMultiCommit = isMultiCommit
        # pylint: disable=E1101
        if self.isMultiCommit and self.cfg_obj.digest:
            self.isLastCommit = False
        return True

    def setLastCommit(self, isLastCommit=False):
        '''
        Tells other methods in class that we have last commit of mutliple.
        '''
        if self.cfg_obj.digest: # pylint: disable=E1101
            self.isLastCommit = isLastCommit
        return True

    def getMessage(self):
        '''
        Returns whole message
        '''
        # Add footer to our message (in digest mode do this only once)
        # pylint: disable=E1101
        if self.cfg_obj.disablefooter == False and self.isLastCommit == True:
            self.footerTextMessage = 'Generated by %s/%s: %s' % (Name,
                __version__, ProjectURL)
            self.footerHtmlMessage = '<br><hr>\nGenerated by %s<br>\n' % \
                ('<a href="%s">%s/%s</a>' % (ProjectURL, Name, __version__))
            self.text_message = '%s\n%s\n' % (self.text_message,
                self.footerTextMessage)
            self.html_message = '%s\n%s\n' % (self.html_message,
                self.footerHtmlMessage)
        # Message parts should be always attached before returning the message.
        self.mail.attachText(self.text_message)
        if self.cfg_obj.colordiff: # pylint: disable=E1101
            self.mail.attachHtml(self.html_message)
        return self.mail.getMessage()

class Utilities(object):
    def __init__(self, cfg_obj):
        self.Tmps = []
        self.cfg_obj = cfg_obj

    def readfile(self, filename=None, mode='r+b'):
        '''
        Reads data from file.
        Empty string returned on error.
        '''
        file_data = ''
        if filename and os.path.exists(filename):
            try:
                with open(filename, mode) as f:
                    file_data = f.read()
            except Exception as __error:
                self.error(u'Reading file %s failed: %s' % (filename,
                    repr(__error)))
        return file_data

    def log(self, msg):
        '''
        Shows message to remote party
        '''
        print >> self.cfg_obj.log, '%s - %s' % (time_asctime(), msg)
        return True

    def error(self, msg):
        '''
        Uses log() function to notify remote party of errors
        '''
        self.log(u'Error: %s' % msg)
        sys.exit(1)

    def makeTmp(self):
        '''
        Create temporary files
        '''
        (fd, fname) = tempfile.mkstemp(prefix="%s-" % Name, suffix=".tmp")
        self.Tmps += [fname]
        return (os.fdopen(fd, "w"), fname)

    def deleteTmps(self):
        '''
        Delete temporary files
        '''
        for tmp in self.Tmps:
            os.unlink(tmp)
        return True

    def upgradeCheck(self):
        '''
        Checks git-notifier for available updates,
        calls __upgradeCode() if necessary.
        '''
        if self.cfg_obj.upgrade:
            self.__upgradeCode()
        return True


    def __upgradeCode(self):
        '''
        Upgrades git-notifier from github.
        Useful for single file intallations.
        '''
        try:
            response = urllib_urlopen(UpdateURL).read()
        except Exception as __error:
            logging.error('Unable to contact update server %s: %s' % \
                (UpdateURL, repr(__error)))
            response = None
        if response:
            try:
                remote_version = re_search("__version__(.*)'([0-9].+)'", 
                     response).group(2)
            except Exception as __error:
                remote_version = None
                logging.error('Unable to parse %s remote version: %s' % \
                    (Name, repr(__error)))
                return False
            if remote_version == __version__:
                logging.warning('%s application is up to date' % Name)
                return True
            elif remote_version:
                logging.warning('Performing upgrade to version %s' % \
                    remote_version)
                myself = sys.argv[0]
                if os.access(myself, os.W_OK):
                    with open(myself, 'w') as fd:
                            fd.write(response)
                    return True

class Notifier(object):
    def __init__(self, cfg_obj):
        self.cfg_obj = cfg_obj
        utilities.log(u'Running for %s' % os.getcwd())

    def debugmode(self):
        '''
        Shows messages to remote party if --debug option specified.
        '''
        # pylint: disable=E1101
        if self.cfg_obj.debug:
            for (name, arg, default, help) in Options:
                logging.error(u'[Option %s: %s]' % (name, 
                    self.cfg_obj.__dict__[name]))
        return True

    def cachestate(self):
        '''
        Stores cached state, logs message in case of initial run.
        '''
        self.cache = State()

        if os.path.exists(CacheFile):
            self.cache.readFrom(CacheFile)
            self.report = (not self.cfg_obj.updateonly) # pylint: disable=E1101
        else:
            utilities.log(u'Initial run. Not generating any mails, \
                just recording current state.')
            self.report = False

        self.current = gitutilities.getCurrent()
        return True

    def diffmode(self):
        '''
        Shows diff. Manual mode only.
        '''
        if self.cfg_obj.diff: # pylint: disable=E1101
            # Manual diff mode.
            # The argument must be of the form "[old-rev..]new-rev".
            # pylint: disable=E1101
            path = [rev.strip() for rev in self.cfg_obj.diff.split("..")]
            if len(path) == 1:
                path = ("%s~2" % path[0], path[0]) # sic! ~2.
            else:
                path = ("%s~1" % path[0], path[1])

            revs = gitutilities.git(["rev-list", "--reverse --date-order",
                path[1], "^%s" % path[0]])
            gitutilities.diffPath("<manual-diff>", revs)

            sys.exit(0)
        return True

    def manualmode(self):
        '''
        Shows diff. Manual mode only.
        '''
        if self.cfg_obj.manual: # pylint: disable=E1101
            # Manual report mode.
            # The argument must be of the form "[old-rev..]new-rev".
            # pylint: disable=E1101
            path = [rev.strip() for rev in self.cfg_obj.manual.split("..")]
            if len(path) == 1:
                path = ("%s~1" % path[0], path[0])

            revs = gitutilities.git(["rev-list", "--reverse --date-order",
                path[1], "^%s" % path[0]])
            gitutilities.reportPath(self.current, revs, force=True)
            sys.exit(0)
        return True

    def reportmode(self):
        '''
        This method is called under normal operations.
        Sends commit notifications.
        '''
        if self.report:
            # Check for changes to the set of heads.
            old = set(self.cache.heads.keys())
            new = set(self.current.heads.keys())

            for head in (new - old):
                gitutilities.entryAdded("branch", head,
                    self.current.heads[head])

            for head in (old - new):
                gitutilities.entryDeleted("branch", head)

            stable_heads = new & old
            self.cfg_obj.allchanges = self.cfg_obj.allchanges & stable_heads

            # Check tags.
            old = set(self.cache.tags.keys())
            new = set(self.current.tags.keys())

            for tag in (new - old):
                gitutilities.entryAdded("tag", tag, self.current.tags[tag])

            for tag in (old - new):
                gitutilities.entryDeleted("tag", tag)

            # Notify for unreported commits.
            old = set(self.cache.revs)
            new = set(self.current.revs)
            new_revs = (new - old)
            gitutilities.reportPath(self.current, new_revs)

            # Do reports for the heads we want to see everything for.
            for head in stable_heads:
                old_rev = self.cache.heads[head]
                new_rev = self.current.heads[head]
                path = gitutilities.git(["rev-list",
                    "--reverse --date-order", new_rev, "^%s" % old_rev])

                if head in self.cfg_obj.allchanges:
                    # Want to see all commits for this head,
                    # even if already reported
                    # in the past for some other. So we record these separately.
                    gitutilities.reportPath(self.current, path,
                        subject_head=head)
                else:
                    # Just send a summary for heads
                    # that now include some new stuff.
                    if len(set(path) - new_revs):
                        gitutilities.headMoved(head, path)
        return True

    def storecache(self):
        '''
        Stores cache after run.
        '''
        if not self.cfg_obj.noupdate: # pylint: disable=E1101
            self.current.writeTo(CacheFile)
        return True

    def cleanup(self):
        '''
        Cleans up after run.
        temporary files are removed here.
        '''
        utilities.deleteTmps()
        return True

    def run(self):
        '''
        Calls Notifier class methods in necessary order.
        This is the main method as well.
        '''
        self.debugmode()
        self.cachestate()
        self.diffmode()
        self.manualmode()
        self.reportmode()
        self.storecache()
        self.cleanup()

if __name__ == "__main__":
    gitutilities = GitUtilities()
    Config = GitConfig(sys.argv[1:])
    utilities = Utilities(Config)
    utilities.upgradeCheck()
    mail = Mail(Config)
    message = MailWrapper(mail, Config)
    notifier = Notifier(Config)
    notifier.run()
