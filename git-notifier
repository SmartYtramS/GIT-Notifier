#!/usr/bin/env python

'''
This is a fork of ICIR.org git-notifier that implements colorized diff support
plus some other nice things.
Please refer to https://github.com/tb0hdan/GIT-Notifier for more detail.
'''

# pylint: disable=C0103,C0302
import optparse
import os
import shutil
import socket
import sys
import subprocess
import tempfile
import logging
import smtplib
from time import asctime as time_asctime
from re import sub as re_sub, search as re_search, split as re_split
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

try:
    eval("1 if True else 2")
except SyntaxError:
    raise ImportError("This software requires ternary support.")

try:
    import pygments
    from pygments import highlight
    from pygments.lexers import DiffLexer # pylint: disable=E0611
    from pygments.formatters import HtmlFormatter # pylint: disable=E0611
    # pylint: disable=E0611
    from pygments.styles import get_style_by_name, STYLE_MAP
    pygments_available = True
except ImportError:
    pygments_available = False

if pygments_available:
    if float(pygments.__version__) < 0.7:
        logging.warning('You have an outdated Pygments version installed.')
        logging.warning('Disabling Pygments support.')
        pygments_available = False

VERSION       = "0.4"
ProjectURL    = "https://github.com/tb0hdan/GIT-Notifier"
Name          = "git-notifier"
CacheFile     = ".%s.dat" % Name
Separator     = "\n>%s\n" % ('-' * 62)
Separhtml     = "<hr>"
NoDiff        = "[nodiff]"
NoMail        = "[nomail]"

gitolite = "GL_USER" in os.environ
# Git via Apache/DAV fix
try:
    whoami = os.environ["LOGNAME"]
except KeyError:
    import getpass
    whoami =  getpass.getuser()
sender = os.environ["GL_USER"] if gitolite else whoami

Options = [
    # Name, argument, default, help,
    ("allchanges", True, set(),
     "branches for which *all* changes are to be reported"),
    ("altsubject", False, False,
     "enables alternative subject with repository name"),
    ("debug", False, False, "enable debug output"),
    ("diff", True, None, "mail out diffs between two revisions"),
    ("emailprefix", True, "[git]", "Subject prefix for mails"),
    ("disablefooter", False, False, 
    "enables page footer for all commit messages"),
    ("digest", False, False,
    "Send multiple commit notification as single message"),
    ("hostname", True, socket.gethostname(),
     "host where the repository is hosted"),
    ("log", True, "%s.log" % Name, "set log output"),
    ("mailinglist", True, whoami, "destination address for mails"),
    ("smtpserver", True, 'localhost', "tells SMTP server to use, host only"),
    ("smtpport", True, 25, "sets SMTP port for SMTP server"),
    ("smtplogin", True, None, "sets login for SMTP AUTH"),
    ("smtppassword", True, None, "sets password for SMTP AUTH"),
    ("smtpssl", False, False, "enables SSL for SMTP"),
    ("manual", True, None, "notify for a manually given set of revisions"),
    ("maxdiffsize", True, 50, "limit the size of diffs in mails (KB)"),
    ("colordiff", False, False, "colorize diffs using pygments library"),
    ("colorstyle", True, "tango",
    "defines style for colordiff option"),
    ("noupdate", False, False, "do not update the state file"),
    ("repouri", True, None, "full URI for the repository"),
    ("sender", True, sender, "sender address for mails"),
    ("link", True, None,
     "Link to insert into mail, %s will be replaced with revision"),
    ("updateonly", False, False, "update state file only, no mails"),
    ("users", True, None, "location of a user-to-email mapping file"),
    ("replyto", True, None, "email address for reply-to header"),
    ("mergediffs", True, set(),
     "branches for which complete merge diffs are to be included"),
    ]


class State(object):
    '''
    State class
    '''
    def __init__(self):
        self.clear()

    def clear(self):
        '''
        Clear data structures
        '''
        self.heads = {}
        self.tags = {}
        self.revs = set()
        self.diffs = set()

        self.reported = set() # Revs reported this run so far.

    def writeTo(self, file):
        '''
        Write to cache file
        '''
        if os.path.exists(CacheFile):
            try:
                shutil.move(CacheFile, CacheFile + ".bak")
            except IOError:
                pass

        out = open(file, "w")

        for (head, ref) in self.heads.items():
            print >> out, "head", head, ref

        for (tag, ref) in self.tags.items():
            print >> out, "tag", tag, ref

        for rev in self.revs:
            print >> out, "rev", rev


    def readFrom(self, file):
        '''
        Read from cache file
        '''
        self.clear()

        for line in open(file):

            line = line.strip()
            if not line or line.startswith("#"):
                continue

            m = line.split()

            if len(m) == 3:
                (type, key, val) = (m[0], m[1], m[2])
            else:
                # No heads.
                (type, key, val) = (m[0], m[1], "")

            if type == "head":
                self.heads[key] = val

            elif type == "tag":
                self.tags[key] = val

            elif type == "rev":
                self.revs.add(key)

            elif type == "diff":
                self.diffs.add(key)

            else:
                error("unknown type %s in cache file" % type)

class GitConfig(object):
    '''
    GitConfig class
    '''
    def __init__(self, args):
        self.parseArgs(args)
        # KBytes to bytes.
        self.maxdiffsize *= 1024 # pylint: disable=E1101


        if self.allchanges and not isinstance(self.allchanges, set):
            self.allchanges = \
                set([head.strip() for head in self.allchanges.split(",")])

        if self.mergediffs and not isinstance(self.mergediffs, set):
            # pylint: disable=E1101
            self.mergediffs = \
                set([head.strip() for head in self.mergediffs.split(",")])

        if not self.debug: # pylint: disable=E1101
            self.log = open(self.log, "a")
        else:
            self.log = sys.stderr

        if not self.users and "GL_ADMINDIR" in os.environ:
            users = os.path.join(os.environ["GL_ADMINDIR"], "conf/sender.cfg")
            if os.path.exists(users):
                self.users = users

        self.readUsers()

    def parseArgs(self, args):
        '''
        Parse command line arguments
        '''
        parser = optparse.OptionParser(version=VERSION)

        for (name, arg, default, help) in Options:
            defval = self._git_config(name, default)

            if isinstance(default, int):
                defval = int(defval)

            if not arg:
                defval = bool(defval)

            if not arg:
                action = "store_true" if not default else "store_false"
                parser.add_option("--%s" % name, action=action, dest=name,
                    default=defval, help=help)

            else:
                type = "string" if not isinstance(default, int) else "int"
                parser.add_option("--%s" % name, action="store", type=type,
                    default=defval, dest=name, help=help)

        (options, args) = parser.parse_args(args)

        if len(args) != 0:
            parser.error("incorrect number of arguments")

        for (name, arg, default, help) in Options:
            self.__dict__[name] = options.__dict__[name]

    def readUsers(self):
        '''
        Read users from configuration file
        '''
        if self.users and os.path.exists(self.users):
            for line in open(self.users):
                line = line.strip()
                if not line or line.startswith("#"):
                    continue

                m = line.split()

                if self.sender == m[0]:
                    self.sender = " ".join(m[1:])
                    break

    def _git_config(self, key, default):
        '''
        Return git configuration
        '''
        cfg = git(["config hooks.%s" % key])
        return cfg[0] if cfg else default

class Colorer(object):
    '''
    Simple class that uses Pygments library to provide colorized
    output (full HTML) for diffs.
    '''
    def __init__(self):
        self.result = ''
        if pygments_available:
            if not Config.colorstyle in STYLE_MAP:
                logging.warning('Specified color style not available.')
                logging.warning('Using default instead.')
                self.style = 'default'
            else:
                self.style = Config.colorstyle
            self.formatter = HtmlFormatter(linenos=True, full=True,
                encoding="utf-8", style=get_style_by_name(self.style))
            self.lexerobj  = DiffLexer()

    def formatDiff(self, data=None):
        '''
        Format diff
        '''
        self.data = data
        if self.data:
            try:
                self.result = highlight(self.data, self.lexerobj,
                    self.formatter)
            except:
                self.result = self.data
        return self.result

    def colorizeFile(self, fname=None, key_start=None, key_end=None):
        '''
        Colorizes input file. Result is HTML.
        '''
        if fname and os.path.exists(fname):
            __data = readfile(fname)
            # We have data, good.
            if (key_start == None) and (key_end == None):
                return self.formatDiff(__data)
            else:
                # Since we have text file here such split works just fine.
                __trigger = False
                __result_data = __noformat_data = ''
                for line in __data.split('\n'):
                    if key_start and (re_search(key_start, line) != None):
                        __trigger = True
                    if key_end   and (re_search(key_end,   line) != None):
                        __trigger = False
                    if  __trigger:
                        __result_data += line + '\n'
                    else:
                        __noformat_data += line + '\n'
                __noformat_data ='<pre>%s</pre>' % __noformat_data
                __result_data = '%s\n%s' % (__noformat_data,
                        self.formatDiff(__result_data))
                return __result_data
        else:
            return None

class PrettyHTML(object):
    '''
    Simple class to make 'git show' message look prettier
    '''
    def __init__(self, subject=None):
        self.keywords = ['commit', 'Author:', 'Date:']
        # If True all next messages are not checked against keywords
        self.keywords_trigger = False
        # Contains additional tags before the commit message
        self.extra_tags = ''
        # Mailto subject part
        self.subject = subject
        if not self.subject:
            self.subject = 'Git commit'

    def transcode(self, line):
        '''
        Encodes characters to HTML
        '''
        self.line = line
        self.line = self.line.replace('<', '&lt;').replace('>', '&gt;')
        # Required for mailto subject encoding
        self.line = self.line.replace(' ', '%20')
        return self.line

    def make_bold(self, keyword, line):
        '''
        Makes text bold
        '''
        part1 = ''
        part2 = ''
        if (re_search(keyword, line) != None) and \
            (self.keywords_trigger == False):
            if re_search(':', keyword) == None:
                replacement = '%s:' % keyword
            else:
                replacement = keyword
            # commit replacement
            if (keyword in self.keywords) and (not replacement[:1].isupper()):
                replacement = replacement[0].upper() + replacement[1:]
            # git commit email
            if re_search('[A|a]uthor', keyword) != None:
                try:
                    part1 = re_split('<(.*)>', line)[0].strip()
                    part2 = re_split('<(.*)>', line)[1].strip()
                except:
                    log("Broken email?")
                if (part1 != '') and (part2 != ''):
                    email = part2
                    uri = '<a href="mailto:%s?subject=%s">&lt;%s&gt;</a>' % \
                     (email, self.transcode(self.subject), email)
                    line = part1 + ' ' + uri
            line = line.replace(keyword, '<b>%s</b>' % replacement)
            line = "<br>%s" % line
        return line

    def convert(self, line):
        '''
        Convert 'git show' keywords
        '''
        replacements = 0
        for keyword in self.keywords:
            line_orig = line
            line = self.make_bold(keyword, line)
            if line != line_orig:
                replacements += 1
        # No replacements were made, assume we have commit message
        if replacements == 0:
            if self.keywords_trigger == False:
                self.keywords_trigger = True
                self.extra_tags = '<br>'
            else:
                # Only on-change lines should have extra tags
                self.extra_tags = ''
            line = '%s<br><b>%s</b>' % (self.extra_tags, line)
        return line

class Mail(object):
    '''
    Simple class for notifications via SMTP
    '''
    def __init__(self, smtp_host, smtp_port, smtp_login,
        smtp_password, smtp_usessl):

        self.smtp_host = smtp_host
        self.smtp_port = smtp_port
        self.smtp_login = smtp_login
        self.smtp_password = smtp_password
        self.smtp_usessl = smtp_usessl
        # Create message container
        # The correct MIME type is multipart/alternative.
        self.msg = MIMEMultipart('alternative')


    def addHeader(self, header, value, header_append=False):
        '''
        Adds message header
        '''
        # Verify presence of header
        if self.msg[header]:
            # Header already set, look out for recepient duplicates!
            if not header_append:
                return False
            del self.msg[header]
        # Set message header
        self.msg[header] = value
        return True

    def addPart(self, content_type, content, encoding=None):
        '''
        Adds message part
        '''
        if encoding:
            # Use specified encoding
            part = MIMEText(content, content_type, encoding)
        else:
            # Fallback to us-ascii
            part = MIMEText(content, content_type)
        return part

    def attach(self, part):
        '''
        Attach message part
        '''
        self.msg.attach(part)

    def attachHtml(self, content):
        '''
        Attach HTML message
        '''
        part = self.addPart('html', content, 'utf8')
        self.attach(part)

    def attachText(self, content):
        '''
        Attach text message
        '''
        part = self.addPart('plain', content)
        self.attach(part)

    def getMessage(self):
        '''
        Return whole message (so far)
        '''
        return self.msg

    def send(self, smtp_sender, smtp_mailinglist, smtp_data):
        '''
        Send email via SMTP
        '''
        log("Sending email to %s" % smtp_mailinglist)
        self.connection = smtplib.SMTP(self.smtp_host)
        try:
            # identify ourselves, prompting server for supported features
            self.connection.ehlo()

            # Encrypt connection if both server supports it
            # and self.smtp_usessl is True
            if self.connection.has_extn('STARTTLS') and self.smtp_usessl:
                self.connection.starttls()
                # re-identify ourselves over TLS connection
                self.connection.ehlo()

            # Enable SMTP AUTH if both self.smtp_login and
            # self.smtp_password are not empty.
            if self.smtp_login and self.smtp_password:
                self.connection.login(self.smtp_login, self.smtp_password)

            # Send message
            self.connection.sendmail(smtp_sender, smtp_mailinglist, smtp_data)
        except:
            # Status of message: delivery failed
            return False
        finally:
            self.connection.quit()
        # Status of message: delivery successful
        return True
        
class MailWrapper(object):
    '''
    MailWrapper class provides high level interface to Mail class
    '''
    def __init__(self, mail_object):
        self.mail = mail_object
        self.isLastCommit = True
        self.text_message_defaults = ''
        self.text_message = self.text_message_defaults
        self.html_message_defaults = '<html>\n'
        self.html_message = self.html_message_defaults

    def init(self, text=None, html=None):
        '''
        Start with reasonable defaults.
        '''
        if text:
            self.text_message = text
        elif not Config.digest:
            self.text_message = self.text_message_defaults
        if html:
            self.html_message = html
        elif not Config.digest:
            self.html_message = self.html_message_defaults

    def sendFile(self, out, fname):
        '''
        Send file contents via SMTP
        '''
        out.close()
        if Config.debug: # pylint: disable=E1101
            for line in open(fname):
                print "    |", line,
            print ""
        elif self.isLastCommit:
            _data = readfile(fname)
            # pylint: disable=E1101
            self.mail.send(Config.sender, Config.mailinglist, _data)

    def generateMailHeader(self, subject):
        '''
        Generates mail header
        '''
        # Reply-To equals to sender, if not set.
        # pylint: disable=E1101
        replyto = 'Reply-To: %s\n' % \
            Config.replyto if Config.replyto else Config.sender
        if Config.altsubject:
            subject = ('Repository: %s Branch: %s ' % \
                (re_sub('ssh://(.+)/', '',repo), subject))

        # Set message headers
        self.mail.addHeader('From', Config.sender)
        self.mail.addHeader('To', Config.mailinglist)
        # Allow only 'Subject' header replacement.
        self.mail.addHeader('Subject',
            Config.emailprefix + subject, header_append=True)
        self.mail.addHeader('Reply-To', replyto)
        self.mail.addHeader('X-Git-Repository', repo)
        self.mail.addHeader('X-Mailer', Name + ' ' + VERSION)

    def addTag(self, key, value):
        '''
        Adds message tag
        '''
        if Config.colordiff: # pylint: disable=E1101
            formatted = '<br><b>%-11s:</b> %s\n' % (key, value)
            self.addLine(formatted, html_only=True, start_br=False)
        else:
            formatted = '%-11s: %s' % (key, value)
            self.addLine(formatted, text_only=True)

    def __br_process(self, start_br, message, line):
        '''
        Internal method to stay DRY
        '''
        if start_br:
            message += '<br>%s' % line
        else:
            message += line
        return message

    def addLine(self, line, text_only=False, html_only=False, start_br=True):
        '''
        Adds message line
        '''
        if text_only:
            self.text_message += line
            return True
        if html_only:
            if Config.colordiff: # pylint: disable=E1101
                self.html_message = self.__br_process(start_br, 
                    self.html_message,line)
            return True
        self.text_message += line
        if Config.colordiff: # pylint: disable=E1101
            self.html_message = self.__br_process(start_br, 
                self.html_message, line)
        return True

    def setMultiCommit(self, isMultiCommit=False):
        '''
        Tells other methods in class that we have multiple commits.
        '''
        self.isMultiCommit = isMultiCommit
        if self.isMultiCommit and Config.digest:
            self.isLastCommit = False
        return True

    def setLastCommit(self, isLastCommit=False):
        '''
        Tells other methods in class that we have last commit of mutliple.
        '''
        if Config.digest:
            self.isLastCommit = isLastCommit
        return True

    def getMessage(self):
        '''
        Returns whole message
        '''
        # Add footer to our message (in digest mode do this only once)
        if Config.disablefooter == False and self.isLastCommit == True:
            self.footerTextMessage = 'Generated by %s/%s: %s' % (Name,
                VERSION, ProjectURL)
            self.footerHtmlMessage = '<br><hr>\nGenerated by %s<br>\n' % \
                ('<a href="%s">%s/%s</a>' % (ProjectURL, Name, VERSION))
            self.text_message = '%s\n%s\n' % (self.text_message, 
                self.footerTextMessage)
            self.html_message = '%s\n%s\n' % (self.html_message,
                self.footerHtmlMessage)
        # Message parts should be always attached before returning the message.
        self.mail.attachText(self.text_message)
        if Config.colordiff: # pylint: disable=E1101
            self.mail.attachHtml(self.html_message)
        return self.mail.getMessage()

def readfile(filename=None, mode='r+b'):
    '''
    Returns data read from file
    '''
    file_data = ''
    if filename and os.path.exists(filename):
        f = open(filename, mode)
        try:
            file_data = f.read()
        except:
            error("Reading file %s failed" % filename)
        finally:
            f.close()
    return file_data

def log(msg):
    '''
    Shows message to remote party
    '''
    print >> Config.log, "%s - %s" % (time_asctime(), msg)

def error(msg):
    '''
    Uses log() function to notify remote party of errors
    '''
    log("Error: %s" % msg)
    sys.exit(1)

def git(args, stdout_to=subprocess.PIPE, all=False):
    '''
    Provides pythonic interface to git executable
    '''
    if isinstance(args, tuple) or isinstance(args, list):
        args = " ".join(args)

    try:
        if Config.debug: # pylint: disable=E1101
            print >> sys.stderr, "> git " + args
    except NameError:
        # Config may not be defined yet.
        pass

    try:
        child = subprocess.Popen("git " + args, shell=True, stdin=None,
            stdout=stdout_to, stderr=subprocess.PIPE)
        (stdout, stderr) = child.communicate()
    except OSError, e:
        error("cannot start git: %s" % str(e))

    if child.returncode != 0 and stderr:
        msg = ": %s" % stderr if stderr else ""
        error("git child failed with exit code %d%s" % (child.returncode, msg))

    if stdout_to != subprocess.PIPE:
        return []

    if not all:
        return [line.strip() for line in stdout.split("\n") if line]
    else:
        return stdout.split("\n")

def getHeads(state):
    '''
    Retrieves information about repository heads
    '''
    for (rev, head) in [head.split() for head in git("show-ref --heads")]:
        if head.startswith("refs/heads/"):
            head = head[11:]

        state.heads[head] = rev

def getTags(state):
    '''
    Retrieves information about repository tags
    '''
    for (rev, tag) in [head.split() for head in git("show-ref --tags")]:
        # We are only interested in annotaged tags.
        tag_type = git("cat-file -t %s" % rev)[0]

        if tag_type == "tag":
            if tag.startswith("refs/tags/"):
                tag = tag[10:]

            state.tags[tag] = rev

def getReachableRefs(state):
    '''
    Retrieves information about reachable repository revisions.
    Result is an array.
    '''
    for rev in git(["rev-list"] + state.heads.keys() + state.tags.keys()):
        state.revs.add(rev)

def getCurrent():
    '''
    Read current state from file.
    '''
    state = State()
    getHeads(state)
    getTags(state)
    getReachableRefs(state)

    return state

def makeTmp():
    '''
    Create temporary files
    '''
    global Tmps

    (fd, fname) = tempfile.mkstemp(prefix="%s-" % Name, suffix=".tmp")
    Tmps += [fname]

    return (os.fdopen(fd, "w"), fname)

def deleteTmps():
    '''
    Delete temporary files
    '''
    for tmp in Tmps:
        os.unlink(tmp)

def getRepo():
    '''
    Retrieve repository path
    '''
    repo = Config.repouri # pylint: disable=E1101
    if not repo:
        if gitolite:
            # Gitolite version.
            # pylint: disable=E1101
            repo = "ssh://%s@%s/%s" % (whoami, Config.hostname,
                os.path.basename(os.getcwd()))
        else:
            # Standard version.
            # pylint: disable=E1101
            repo = "ssh://%s/%s" % (Config.hostname,
                os.path.basename(os.getcwd()))
        if repo.endswith(".git"):
            repo = repo[0:-4]
    return repo

def entryAdded(key, value, rev):
    '''
    Hook for adding an entry
    '''
    log("New %s %s" % (key, value))
    (out, fname) = makeTmp()

    # Initialize message
    message.init()
    message.generateMailHeader("%s '%s' created" % (key, value))

    message.addTag("New %s" % key, value)
    message.addTag("Referencing", rev)

    # print whole message to file
    print >> out, message.getMessage()
    message.sendFile(out, fname)

def entryDeleted(key, value):
    '''
    Hook for deleting an entry
    '''
    log("Deleted %s %s" % (key, value))
    (out, fname) = makeTmp()

    # Initialize message
    message.init()
    message.generateMailHeader("%s '%s' deleted" % (key, value))

    message.addTag("Deleted %s" % key, value)

    # print whole message to file
    print >> out, message.getMessage()
    message.sendFile(out, fname)

def sendChangeMail(rev, subject, heads, show_cmd, diff_cmd):
    '''
    Sends a mail for a notification consistent of two parts: (1) the output of
    a show command, and (2) the output of a diff command.
    '''
    # The 'git show' prettifier
    prettyhtml = PrettyHTML(subject='Git commit %s' % subject[-9:])
    # Initialize message
    message.init()
    message.generateMailHeader(subject)
    (out, fname) = makeTmp()
    #
    message.addTag("Repository", repo)

    multi = "es" if len(heads) > 1 else ""
    heads = ",".join(heads)

    message.addTag("On branch%s" % multi, heads)

    if Config.link: # pylint: disable=E1101
        url = Config.link.replace("%s", rev) # pylint: disable=E1101
        message.addTag("Link", url)

    footer = ""
    show = git(show_cmd)

    for line in show:
        if NoDiff in line:
            break

        if NoMail in line:
            return

    else:
        (tmp, tname) = makeTmp()
        # TODO: Find better place for this
        diff = git(diff_cmd, stdout_to=tmp)
        tmp.close()

        size = os.path.getsize(tname)
        if size > Config.maxdiffsize: # pylint: disable=E1101
            footer = "\nDiff suppressed because of size.\n \
                To see it, use:\n\n    git %s" % diff_cmd
            tname = None

    message.addLine(Separator, text_only=True)
    # Use nice <hr> in html mode
    message.addLine(Separhtml, html_only=True)

    for line in git(show_cmd, all=True):
        if line == "---":
            message.addLine(Separator, text_only=True)
            message.addLine(Separhtml, html_only=True)
        else:
            message.addLine(line + "\n", text_only=True)
            message.addLine(prettyhtml.convert(line) + "\n",
                html_only=True, start_br=False)

    message.addLine(Separator, text_only=True)
    message.addLine(Separhtml, html_only=True)

    # Text only, read diff from file
    if tname:
        for line in open(tname):
            message.addLine(line, text_only=True)

    # HTML only, read and parse diff
    if Config.colordiff and tname: # pylint: disable=E1101
        colorer = Colorer()
        message.addLine('\n', html_only=True, start_br=False)
        message.addLine(colorer.colorizeFile(tname, key_start='diff\ --git'),
            html_only=True, start_br=False)

    message.addLine(footer, text_only=True)
    message.addLine(footer.replace("\n", "<br>\n"), html_only=True)

    if Config.debug: # pylint: disable=E1101
        message.addLine("-- ", text_only=True)
        # Use nice <hr> in html mode
        message.addLine(Separhtml, html_only=True)
        # Both text and html
        message.addLine("debug: show_cmd = git %s" % show_cmd)
        message.addLine("debug: diff_cmd = git %s" % diff_cmd)

    # print whole message to file
    print >> out, message.getMessage()
    message.sendFile(out, fname)

def commit(current, rev, force=False, subject_head=None):
    '''
    Sends notification for a specific revision.
    '''
    if rev in current.reported and not force:
        # Already reported in this run of the script.
        log("Flagged revision %s for notification, \
            but already reported this time" % rev)
        return

    log("New revision %s" % rev)
    current.reported.add(rev)

    heads = [head.split()[-1] for head in git("branch --contains=%s" % rev)]
    if not subject_head:
        subject_head = ",".join(heads)

    merge_diff = "--cc"

    for head in heads:
        if head in Config.allchanges or head in Config.mergediffs:
            merge_diff = "-m"

    subject = git("show '--pretty=format:%%s (%%h)' -s %s" % rev)
    subject = "%s: %s" % (subject_head, subject[0])

    show_cmd = "show -s --no-color --find-copies-harder \
        --pretty=medium %s" % rev
    diff_cmd = "diff-tree --patch-with-stat --no-color --find-copies-harder \
        --ignore-space-at-eol %s %s" % (merge_diff, rev)

    sendChangeMail(rev, subject, heads, show_cmd, diff_cmd)

def diff(head, first, last):
    '''
    Sends a diff between two revisions.
    Only used in manual mode now.
    '''
    # We record a pseudo-revision to avoid sending the same diff twice.
    rev = "%s-%s" % (head, last)
    if not rev in current.diffs:
        log("New diff revision %s" % rev)
        current.diffs.add(rev)

    log("Diffing %s..%s" % (first, last))

    subject = git("show '--pretty=format:%%s (%%h)' -s %s" % last)
    subject = "%s diff: %s" % (head, subject[0])

    heads = [head]

    show_cmd = "show -s --no-color --find-copies-harder \
        --pretty=medium %s" % last
    diff_cmd = "diff --patch-with-stat -m --no-color --find-copies-harder \
        --ignore-space-at-eol %s %s" % (first, last)

    sendChangeMail(last, subject, heads, show_cmd, diff_cmd)

def diffPath(head, revs):
    '''
    Sends pair-wise diffs for a path of revisions. Also records all revision on
    the path as seen.
    Only used in manual mode now.
    '''
    last = None

    for rev in revs:
        if last:
            diff(head, last, rev)
        last = rev

def reportPath(current, revs, force=False, subject_head=None):
    '''
    Sends a commit notifications for a set of revisions.
    '''
    if not revs:
        return

    # Sort updates by time.
    revs = git("rev-list --no-walk --reverse --date-order %s" % " ".join(revs))

    if len(revs) > 1:
        message.setMultiCommit(True)

    for rev in revs:
        # Get last revision
        if rev == revs[len(revs)-1]:
            message.setLastCommit(True)
        commit(current, rev, force=force, subject_head=subject_head)


def headMoved(head, path):
    '''
    Sends a summary mail for a set of revisions.
    '''
    log("Head moved: %s -> %s" % (head, path[-1]))
    (out, fname) = makeTmp()

    subject = git("show '--pretty=format:%%s (%%h)' -s %s" % path[-1])

    # Initialize message
    message.init()
    message.generateMailHeader("%s's head updated: %s" % (head, subject[0]))

    message.addLine("Branch '%s' now includes:" % head)
    message.addLine("")

    for rev in path:
        message.addLine("    " +
            str(git("show -s --pretty=oneline --abbrev-commit %s" % rev)[0]))

    # print whole message to file
    print >> out, message.getMessage()
    message.sendFile(out, fname)

# Main run
Tmps = []

Config = GitConfig(sys.argv[1:])
# pylint: disable=E1101
mail = Mail(Config.smtpserver, Config.smtpport,
            Config.smtplogin, Config.smtppassword, Config.smtpssl)

message = MailWrapper(mail)

repo = getRepo()

log("Running for %s" % os.getcwd())

if Config.debug:
    for (name, arg, default, help) in Options:
        print >> sys.stderr, "[Option %s: %s]" % (name, Config.__dict__[name])

cache = State()

if os.path.exists(CacheFile):
    cache.readFrom(CacheFile)
    report = (not Config.updateonly)
else:
    log("Initial run. Not generating any mails, just recording current state.")
    report = False

current = getCurrent()

if Config.diff:
    # Manual diff mode. The argument must be of the form "[old-rev..]new-rev".
    path = [rev.strip() for rev in Config.diff.split("..")]
    if len(path) == 1:
        path = ("%s~2" % path[0], path[0]) # sic! ~2.
    else:
        path = ("%s~1" % path[0], path[1])

    revs = git(["rev-list", "--reverse --date-order", path[1], "^%s" % path[0]])

    diffPath("<manual-diff>", revs)

    sys.exit(0)

if Config.manual:
    # Manual report mode. The argument must be of the form "[old-rev..]new-rev".
    path = [rev.strip() for rev in Config.manual.split("..")]
    if len(path) == 1:
        path = ("%s~1" % path[0], path[0])

    revs = git(["rev-list", "--reverse --date-order", path[1], "^%s" % path[0]])
    reportPath(current, revs, force=True)

    sys.exit(0)

if report:
    # Check for changes to the set of heads.
    old = set(cache.heads.keys())
    new = set(current.heads.keys())

    for head in (new - old):
        entryAdded("branch", head, current.heads[head])

    for head in (old - new):
        entryDeleted("branch", head)

    stable_heads = new & old
    Config.allchanges = Config.allchanges & stable_heads

    # Check tags.
    old = set(cache.tags.keys())
    new = set(current.tags.keys())

    for tag in (new - old):
        entryAdded("tag", tag, current.tags[tag])

    for tag in (old - new):
        entryDeleted("tag", tag)

    # Notify for unreported commits.
    old = set(cache.revs)
    new = set(current.revs)
    new_revs = (new - old)
    reportPath(current, new_revs)

    # Do reports for the heads we want to see everything for.
    for head in stable_heads:
        old_rev = cache.heads[head]
        new_rev = current.heads[head]
        path = git(["rev-list",
            "--reverse --date-order", new_rev, "^%s" % old_rev])

        if head in Config.allchanges:
            # Want to see all commits for this head, even if already reported
            # in the past for some other. So we record these separately.
            reportPath(current, path, subject_head=head)
        else:
            # Just send a summary for heads that now include some new stuff.
            if len(set(path) - new_revs):
                headMoved(head, path)

if not Config.noupdate:
    current.writeTo(CacheFile)

deleteTmps()
